{"version":3,"sources":["webpack://Pi/webpack/universalModuleDefinition","webpack://Pi/./src/maths/algebra/equation.ts","webpack://Pi/./src/maths/algebra/linearSystem.ts","webpack://Pi/./src/maths/algebra/monom.ts","webpack://Pi/./src/maths/algebra/polynom.ts","webpack://Pi/./src/maths/algebra/rational.ts","webpack://Pi/./src/maths/coefficients/fraction.ts","webpack://Pi/./src/maths/coefficients/nthroot.ts","webpack://Pi/./src/maths/geometry/line.ts","webpack://Pi/./src/maths/geometry/point.ts","webpack://Pi/./src/maths/geometry/triangle.ts","webpack://Pi/./src/maths/geometry/vector.ts","webpack://Pi/./src/maths/numeric.ts","webpack://Pi/./src/maths/shutingyard.ts","webpack://Pi/webpack/bootstrap","webpack://Pi/./src/index.ts"],"names":["root","factory","exports","module","define","amd","self","Equation","_left","_right","_sign","_polynom","_solutions","_varnothing","_real","constructor","equations","this","Polynom","zero","length","isEquation","clone","parse","left","isPolynom","right","includes","join","undefined","solve","tex","signAsTex","raw","Set","variables","concat","value","_formatSign","equationString","pStr","strSign","_findSign","split","create","console","log","signStr","_reverseSign","replace","sign","_randomizeDefaults","degree","randomize","opts","reorder","allLeft","subtract","mMove","m","monoms","simplify","multiply","Numeric","lcm","getDenominators","divide","gcd","getNumerators","isolate","letter","isMultiVariable","cMove","hasLetter","add","opposed","coefficient","F","Fraction","isZero","invert","Math","max","letters","_solveDegree1","_solveDegree2","_solveDegree3plus","isGreater","indexOf","isStrictEqual","isAlsoEqual","m1","monomByDegree","m0","v","display","s","delta","nthDelta","realX1","realX2","sX1","sX2","aF","bF","cF","denominator","a","b","sqrt","toFixed","Nthroot","reduce","hasRadical","dfrac","LinearSystem","_resolutionSteps","_equations","_letters","equationStrings","V","E","sort","equStr","LS","equArray","equ","L","monomByLetter","push","repeat","isReal","isVarnothing","map","_findLetters","setCoefficient","coefficients","i","slice","toString","setLetters","generate","solutions","solutionsF","_generateOneEquation","coeff","leftValue","equString","randomIntSym","_checkIfLinerCombination","_linearReduction","eq1","eq2","c1","c2","mergeEquations","factor1","factor2","eq1multiplied","eq2multiplied","_solveOneLetter","LE","reducedEquations","str","Monom","_coefficient","_literal","isLitteralSquare","key","inputStr","matchAll","clean","Object","keys","numerator","dividers","abs","litterals","literal","_getLitteralDividers","monomDividers","N","M","one","arr","tmpList","d","litt","item","currentLetter","literalStr","trim","k","setLetter","random","withFraction","allowZero","randomInt","isSameAs","multiplyByNumber","pow","nb","p","isSquare","compare","isEqual","M1","M2","K","filter","isOne","Number","isSafeInteger","values","t","n","evaluate","r","derivative","dM","coeffN","coeffD","min","areSameAs","areEquals","_rawString","_monoms","_factors","_texString","polynomString","factorize","f","factors","x","genDisplay","output","forceSign","wrapParentheses","P","isNaN","empty","shutingYardToReducedPolynom","test","fractions","SY","Shutingyard","rpn","m2","tokenParam","token","isOperation","pop","substr","unit","factorable","allowNullMonom","numberOfMonoms","config","rndSimple","splice","rndFactorable","factorUnit","multiplyByPolynom","multiplyByFraction","multiplyByMonom","multiplyByInteger","xmultiply","euclidian","quotient","reminder","maxMP","degreeP","newM","MaxIteration","divideByInteger","divideByFraction","nbF","cP1","cP2","isOpposedAt","isFactorized","polynomStringNormalized","replaceAll","polynomStringReduced","polyFactors","j","S","replaceBy","resultPolynom","forEach","monom","dP","factorize_OLD","maxValue","nbFactorsFound","commonMonom","commonPolynom","Q","tempPolynom","securityLoop","m1d","m2d","result","dividerPolynom","_factorize2ndDegree","P1","P2","c","x1","x2","factor","numberOfVars","isPositive","xyzPolynom","xFactors","literalSqrt","_factorizeByGroups","getZeroes","zeroes","zeroesAsTex","A","B","C","D","z","frac","monomsByDegree","Ms","denominators","numerators","lcmDenominator","gcdDenominator","lcmNumerator","gcdNumerator","makeItComplicate","complexity","mDegree","factorizePartial","texString","mMain","mCheck","mFactor","pFactor","g","minify","canDivide","evalValue","_numerator","_denominator","texFactors","domain","amplify","NumeratorEuclidien","DenominatorEuclidien","R","denominatorOrPeriodic","NaN","floor","infinite","Infinity","invalid","lesser","than","leq","greater","geq","isDifferent","isOpposed","isInverted","isNegative","isInfinity","isFinite","_radical","_nth","_isValid","radical","nthroot","Line","_a","_b","_c","_OA","_d","_n","_exists","canonical","equation","mxh","slope","OA","height","parametric","Point","pmatrix","y","Vector","parseByCoefficient","isPoint","isVector","parseByPointAndVector","isLine","has","elem","delete","size","normal","isParellelTo","line","simplifyDirection","intersection","Pt","isParallel","isSame","point","hasIntersection","distanceTo","pt","d2","normSquare","fraction","hitSegment","iPt","canonicalAsFloatCoefficient","decimals","_x","_y","_exist","pts","origin","middleOf","texValues","numberOfDigits","_A","_B","_C","_lines","_middles","_remarquables","getSegment","AB","isNormalTo","BC","AC","intersect","isTriangle","_updateTriangle","_calculateRemarquableLines","getPointByName","ptName","toUpperCase","ptName1","ptName2","remarquables","_calculateBisectors","medians","mediators","heights","bisectors","d1","tlines","lines","b1","norm","b2","_parseString","isFraction","reset","components","scalarProductWithVector","v1","v2","multiplyByScalar","scalar","divideByScalar","angleWith","sharp","radian","toDegree","PI","acos","round","primes","maxV","gcd2","percent","randomBool","_rpn","match","NextToken","expr","start","tokenMatch","tokenType","Uniformizer","expr2","outQueue","opStack","precedence","associative","tokenPos","securityLoopLvl2","securityLoopLvl1","opTop","reverse","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","window","Pi","Root","Rational","Geometry","Triangle"],"mappings":"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AM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KA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","file":"pi.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Pi\"] = factory();\n\telse\n\t\troot[\"Pi\"] = factory();\n})(self, function() {\nreturn ","import {Polynom} from \"./polynom\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Nthroot} from \"../coefficients/nthroot\";\r\nimport {Numeric} from \"../numeric\";\r\nimport {Monom} from \"./monom\";\r\n\r\nexport class Equation {\r\n    private _left: Polynom;  // Left part of the equation\r\n    private _right: Polynom; // Right part of the equation\r\n    private _sign: string;   // Signe of the equation, by default =\r\n\r\n    private _polynom: Polynom;  // Used to solve the equation // TODO: remove the private value ?\r\n    private _solutions: string[];    // Array of the solutions\r\n\r\n    // Undetermined solutions.\r\n    private _varnothing: string = '\\\\varnothing';\r\n    private _real: string = '\\\\mathbb{R}';\r\n\r\n    /**\r\n     * Create an Equation using two polynoms.\r\n     * @param equation Equation string\r\n     */\r\n    constructor(...equations: any) {\r\n        // Default equation\r\n        this._left = new Polynom().zero();\r\n        this._right = new Polynom().zero();\r\n        this._sign = '=';\r\n\r\n        if (equations.length === 1) {\r\n            if (equations[0].isEquation === true) {\r\n                return equations[0].clone();\r\n            } else {\r\n                this.parse(equations[0]);\r\n            }\r\n        } else if (equations.length === 2) {\r\n            this.left = equations[0].isPolynom ? equations[0].clone() : new Polynom(equations[0]);\r\n            this.right = equations[1].isPolynom ? equations[1].clone() : new Polynom(equations[1]);\r\n        } else {\r\n            // Return default empty equation\r\n            return this;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    get isEquation() {\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    // TODO: Check the getters and setters.\r\n    get solutions(): string[] {\r\n        return this._solutions;\r\n    }\r\n\r\n    get solution(): string {\r\n        if (this._solutions.length === 1\r\n            &&\r\n            (\r\n                this._solutions[0] === this._real\r\n                || this._solutions[0] === this._varnothing\r\n                || this._solutions[0].includes('\\\\left')\r\n            )\r\n        ) {\r\n            return `S = ${this._solutions[0]}`;\r\n        }\r\n        return `S = \\\\left{ ${this._solutions.join(';')} \\\\right}`;\r\n    }\r\n\r\n    get isReal(): boolean {\r\n        if (this._solutions === undefined) {\r\n            this.solve();\r\n        }\r\n        return this._solutions[0] === this._real;\r\n    }\r\n\r\n    get isVarnothing(): boolean {\r\n        if (this._solutions === undefined) {\r\n            this.solve();\r\n        }\r\n        return this._solutions[0] === this._varnothing;\r\n    }\r\n\r\n    get signAsTex(): string {\r\n        if (this._sign === '>=' || this._sign === '=>' || this._sign === 'geq') {\r\n            return '\\\\geq';\r\n        }\r\n        if (this._sign === '<=' || this._sign === '=<' || this._sign === 'leq') {\r\n            return '\\\\leq';\r\n        }\r\n        return this._sign;\r\n    }\r\n\r\n    get tex(): string {\r\n        return `${this._left.tex}${this.signAsTex}${this._right.tex}`;\r\n    }\r\n\r\n    get raw(): string {\r\n        return `${this._left.raw}${this.signAsTex}${this._right.raw}`;\r\n    }\r\n\r\n    get variables(): string[] {\r\n        return [...new Set(this._right.variables.concat(this._left.variables))];\r\n    }\r\n\r\n    get numberOfVars(): number {\r\n        return this.variables.length;\r\n    }\r\n\r\n    get left(): Polynom {\r\n        return this._left;\r\n    }\r\n\r\n    set left(value: Polynom) {\r\n        this._left = value;\r\n    }\r\n\r\n    get right(): Polynom {\r\n        return this._right;\r\n    }\r\n\r\n    set right(value: Polynom) {\r\n        this._right = value;\r\n    }\r\n\r\n    get sign(): string {\r\n        return this._sign;\r\n    }\r\n\r\n    set sign(value: string) {\r\n        // Set the sign value as formatted.\r\n        this._sign = this._formatSign(value);\r\n    }\r\n\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    parse = (equationString: string): Equation => {\r\n        let pStr: string[], strSign: string | false;\r\n        // Find the string separator\r\n        strSign = this._findSign(equationString);\r\n\r\n        if (strSign === false) {\r\n            console.log('The equation is not valid (no sign found)');\r\n            return;\r\n        }\r\n\r\n        // The StrSign is found\r\n        pStr = equationString.split(strSign);\r\n\r\n        return this.create(new Polynom(pStr[0]), new Polynom(pStr[1]), this._formatSign(strSign));\r\n    };\r\n\r\n    private _findSign = (equationString: string): string | false => {\r\n        let strSign: string = '';\r\n\r\n        if (equationString.includes('geq')) {\r\n            return (equationString.includes('\\\\geq')) ? '\\\\geq' : 'geq';\r\n        } else if (equationString.includes('leq')) {\r\n            return (equationString.includes('\\\\leq')) ? '\\\\leq' : 'leq';\r\n        } else if (equationString.includes('>=')) {\r\n            return '>=';\r\n        } else if (equationString.includes('=>')) {\r\n            return '=>';\r\n        } else if (equationString.includes('>')) {\r\n            return '>';\r\n        } else if (equationString.includes('<=')) {\r\n            return '<=';\r\n        } else if (equationString.includes('=<')) {\r\n            return '=<';\r\n        } else if (equationString.includes('<')) {\r\n            return '<';\r\n        } else if (equationString.includes('=')) {\r\n            return '='\r\n        }\r\n        if (strSign === '') {\r\n            console.log('Equation: parse string : sign not found');\r\n            return false;\r\n        }\r\n    };\r\n\r\n    private _formatSign = (signStr: string): string => {\r\n        if (signStr === undefined) {\r\n            return '=';\r\n        }\r\n\r\n        if (signStr.includes('geq')) {\r\n            return '>=';\r\n        } else if (signStr.includes('>=')) {\r\n            return '>=';\r\n        } else if (signStr.includes('=>')) {\r\n            return '>=';\r\n        } else if (signStr.includes('>')) {\r\n            return '>';\r\n        } else if (signStr.includes('leq')) {\r\n            return '<=';\r\n        } else if (signStr.includes('<=')) {\r\n            return '<=';\r\n        } else if (signStr.includes('=<')) {\r\n            return '<=';\r\n        } else if (signStr.includes('<')) {\r\n            return '<';\r\n        } else {\r\n            return '='\r\n        }\r\n    };\r\n\r\n    private _reverseSign = (): Equation => {\r\n        if (this._sign === '=') {\r\n            return this;\r\n        }\r\n\r\n        if (this._sign.includes('<')) {\r\n            this._sign.replace('<', '>');\r\n            return this;\r\n        }\r\n        if (this._sign.includes('>')) {\r\n            this._sign.replace('>', '<');\r\n            return this;\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    create = (left: Polynom, right: Polynom, sign?: string): Equation => {\r\n        this._left = left;\r\n        this._right = right;\r\n        this._sign = this._formatSign(sign);\r\n        return this;\r\n    };\r\n\r\n    clone = (): Equation => {\r\n        return new Equation().create(this._left.clone(), this._right.clone(), this._sign + '');\r\n    };\r\n\r\n    // -----------------------------------------------\r\n    // Equations generators and randomizers\r\n    // -----------------------------------------------\r\n    private _randomizeDefaults: { [key: string]: number | string | boolean } = {\r\n        degree: 2\r\n    };\r\n    get randomizeDefaults(): { [key: string]: number | string | boolean } {\r\n        return this._randomizeDefaults;\r\n    }\r\n\r\n    set randomizeDefaults(value) {\r\n        this._randomizeDefaults = value;\r\n    }\r\n\r\n    randomize = (opts?: {}, sign?: string): Equation => {\r\n        // TODO: Generate equations randomly, using config.\r\n        return new Equation().create(new Polynom(), new Polynom(), sign);\r\n    };\r\n\r\n\r\n    // -----------------------------------------------\r\n    // Equations operations\r\n    // -----------------------------------------------\r\n    /**\r\n     * Reorder will move all monoms containing a letter on the left, all the other on the right.\r\n     */\r\n    reorder = (allLeft?: boolean): Equation => {\r\n        // Move all monoms of degree greater than 0 to the left.\r\n        // and all zero degree monoms to the right.\r\n        this._left.subtract(this._right);\r\n        this._right.zero();\r\n\r\n        if (allLeft) {\r\n            return this;\r\n        }\r\n        let mMove: Monom;\r\n        for (let m of this._left.monoms) {\r\n            if (m.degree() === 0) {\r\n                mMove = m.clone();\r\n                this._left.subtract(mMove);\r\n                this._right.subtract(mMove);\r\n            }\r\n        }\r\n\r\n        // Reorder the left and right polynoms\r\n        this._left.reorder();\r\n        this._right.reorder();\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Multiply by the lcm denominator and divide by the gcm numerators.\r\n     */\r\n    simplify = (): Equation => {\r\n        this.multiply(Numeric.lcm(...this._left.getDenominators(),...this._right.getDenominators()));\r\n        this.divide(Numeric.gcd(...this._left.getNumerators(),...this._right.getNumerators()));\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reorder the polynom to have only one letter on the left, the rest on the right.\r\n     * @param letter\r\n     */\r\n    isolate = (letter?: string): Equation | false => {\r\n        // Determine if we can isolate the variables.\r\n\r\n        // Both part of the equations must be of the first degree.\r\n        //TODO: handle equations of degree two or more ?\r\n        if (this.degree(letter) !== 1) {\r\n            return false;\r\n        }\r\n\r\n        // Modify the equation to isolate the asked variable.\r\n        // TODO: must handle equations like 3xy+5y=4 => y = 4/(3x-5)\r\n        if (this.isMultiVariable()) {\r\n            return false;\r\n        }\r\n\r\n        // Isolate the letter.\r\n        let mMove: Monom, cMove: Fraction;\r\n        // Start by moving everything to the left.\r\n        this._left.subtract(this._right);\r\n        this._right.zero();\r\n        for (let m of this._left.monoms) {\r\n            if (!m.hasLetter(letter)) {\r\n                mMove = m.clone();\r\n                this._left.add(mMove.clone().opposed());\r\n                this._right.add(mMove.clone().opposed());\r\n            }\r\n        }\r\n\r\n        // In theory, we should have only one item on the left.\r\n        if (this._left.length !== 1) {\r\n            return false;\r\n        }\r\n        cMove = this._left.monoms[0].coefficient.clone();\r\n        this._left.divide(cMove);\r\n        this._right.divide(cMove);\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Multiple an equation by a fraction value.\r\n     * @param F\r\n     */\r\n    multiply = (value: any): Equation => {\r\n\r\n        // Make sure we have a fraction.\r\n        let F: Fraction = new Fraction(value);\r\n\r\n        // Multiply each part of the equation by the fraction\r\n        this._left.multiply(F);\r\n        this._right.multiply(F);\r\n\r\n        // The sign of the inequation must be changed.\r\n        if (this._sign !== '=' && F.sign() === -1) {\r\n            this._reverseSign();\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    divide = (value: any): Equation => {\r\n        // Make sure we have a fraction.\r\n        let F: Fraction = new Fraction(value);\r\n\r\n        if(F.isZero()){\r\n            return this;\r\n        }else {\r\n            return this.multiply(F.invert());\r\n        }\r\n    }\r\n\r\n    // -----------------------------------------------\r\n    // Equations helpers\r\n    // -----------------------------------------------\r\n\r\n    /**\r\n     * Get the degree of the equation\r\n     * @param letter\r\n     */\r\n    degree = (letter?: string): number => {\r\n        return Math.max(this._left.degree(letter), this._right.degree(letter));\r\n    };\r\n\r\n    /**\r\n     * Determine if the equation contains more than one letter/variable.\r\n     */\r\n    isMultiVariable = (): boolean => {\r\n        return this._left.isMultiVariable || this._right.isMultiVariable;\r\n    };\r\n\r\n    letters = (): string[] => {\r\n        // @ts-ignore\r\n        return [...new Set([...this._left.letters(), ...this._right.letters()])];\r\n    }\r\n\r\n    // -----------------------------------------------\r\n    // Equations solving algorithms\r\n    // -----------------------------------------------\r\n    solve = (letter?: string): Equation => {\r\n        // Initialise the variables:\r\n        this._solutions = [];\r\n\r\n        // TODO: this._polynom could be removed.\r\n        // TODO: consolidate solving equations (inequations vs equations)\r\n        this._polynom = this._left.clone().subtract(this._right);\r\n\r\n        switch (this._polynom.degree(letter)) {\r\n            case 0:\r\n            case 1:\r\n                this._solveDegree1(letter);\r\n                break;\r\n            case 2:\r\n                this._solveDegree2(letter);\r\n                break;\r\n            default:\r\n                this._solveDegree3plus(letter);\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    private isGreater = (): boolean => {\r\n        if (this._sign.indexOf('>') !== -1) {\r\n            return true;\r\n        }\r\n        return this._sign.indexOf('geq') !== -1;\r\n\r\n    };\r\n    private isStrictEqual = (): boolean => {\r\n        return this._sign === '=';\r\n    };\r\n    private isAlsoEqual = (): boolean => {\r\n        if (this._sign.indexOf('=') !== -1) {\r\n            return true;\r\n        }\r\n        if (this._sign.indexOf('geq') !== -1) {\r\n            return true;\r\n        }\r\n        if (this._sign.indexOf('leq') !== -1) {\r\n            return true;\r\n        }\r\n    };\r\n\r\n    private _solveDegree1 = (letter?: string): string[] => {\r\n        const m1 = this._polynom.monomByDegree(1, letter).coefficient,\r\n            m0 = this._polynom.monomByDegree(0, letter).coefficient,\r\n            v = m0.clone().opposed().divide(m1).display;\r\n        let s: string;\r\n\r\n        if (this.isStrictEqual()) {\r\n            if (m1.value === 0) {\r\n                // In this case, the coefficient of the x variable is zero.\r\n                if (m0.value === 0) {\r\n                    this._solutions = [this._real];\r\n                } else {\r\n                    this._solutions = [this._varnothing];\r\n                }\r\n            } else {\r\n                this._solutions = [v];\r\n            }\r\n        } else {\r\n            if (m1.value === 0) {\r\n                // In this case, the coefficient of the x variable is zero.\r\n                if (m0.value === 0 && this.isAlsoEqual()) {\r\n                    s = '\\\\mathbb{R}';\r\n                } else {\r\n                    if (m0.value > 0) {\r\n                        s = this.isGreater() ? this._real : this._varnothing;\r\n                    } else {\r\n                        s = !this.isGreater() ? this._real : this._varnothing;\r\n                    }\r\n                }\r\n            } else {\r\n                // Must handle the case if the m1 monom is negative.\r\n                if ((this.isGreater() && m1.sign() === 1) || (!this.isGreater() && m1.sign() === -1)) {\r\n                    s = `\\\\left${this.isAlsoEqual() ? '\\\\[' : '\\\\]'}${v};+\\\\infty\\\\right\\\\[`;\r\n                } else {\r\n                    s = `\\\\left\\\\]-\\\\infty;${v} \\\\right\\\\${this.isAlsoEqual() ? '\\\\]' : '\\\\['}`;\r\n                }\r\n            }\r\n            this._solutions = [s];\r\n        }\r\n\r\n        return this._solutions;\r\n    };\r\n\r\n    private _solveDegree2 = (letter?: string): string[] => {\r\n        let aF = this._polynom.monomByDegree(2, letter).coefficient,\r\n            bF = this._polynom.monomByDegree(1, letter).coefficient,\r\n            cF = this._polynom.monomByDegree(0, letter).coefficient,\r\n            delta: number, nthDelta: Nthroot,\r\n            lcm = Numeric.lcm(aF.denominator, bF.denominator, cF.denominator),\r\n            a = aF.multiply(lcm).value,\r\n            b = bF.multiply(lcm).value,\r\n            c = cF.multiply(lcm).value,\r\n            realX1: number, realX2: number,\r\n            sX1: string, sX2: string;\r\n\r\n        delta = b * b - 4 * a * c;\r\n\r\n        if (delta > 0) {\r\n            realX1 = (-b - Math.sqrt(delta)) / (2 * a);\r\n            realX2 = (-b + Math.sqrt(delta)) / (2 * a);\r\n\r\n            if(delta>1.0e5){\r\n                // The delta is too big to be parsed !\r\n                this._solutions = [\r\n                    ((-b - Math.sqrt(delta))/(2 * a)).toFixed(5),\r\n                    ((-b + Math.sqrt(delta))/(2 * a)).toFixed(5)\r\n                ]\r\n            }else {\r\n                nthDelta = new Nthroot().parse(delta).reduce();\r\n                if (nthDelta.hasRadical()) {\r\n                    // -b +- coeff\\sqrt{radical}\r\n                    // -------------------------\r\n                    //           2a\r\n                    let gcd = Numeric.gcd(b, 2 * a, nthDelta.coefficient);\r\n                    nthDelta.coefficient = nthDelta.coefficient / gcd;\r\n\r\n                    // TODO: Can i delete the next line ?\r\n                    // let deltaC = nthDelta.coefficient, deltaR = nthDelta.radical;\r\n                    if (b !== 0) {\r\n                        if (2 * a / gcd === 1) {\r\n                            this._solutions = [\r\n                                `${-b / gcd} - ${nthDelta.tex}`,\r\n                                `${-b / gcd} + ${nthDelta.tex}`,\r\n                            ]\r\n                        } else {\r\n                            this._solutions = [\r\n                                `\\\\dfrac{${-b / gcd} - ${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                                `\\\\dfrac{${-b / gcd} + ${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                            ]\r\n                        }\r\n                    } else {\r\n                        if (2 * a / gcd === 1) {\r\n                            this._solutions = [\r\n                                `- ${nthDelta.tex}`,\r\n                                `${nthDelta.tex}`,\r\n                            ]\r\n                        } else {\r\n                            this._solutions = [\r\n                                `\\\\dfrac{- ${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                                `\\\\dfrac{${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                            ]\r\n                        }\r\n                    }\r\n                } else {\r\n                    // -b +- d / 2a\r\n                    this._solutions = [\r\n                        new Fraction(-b - nthDelta.coefficient, 2 * a).reduce().dfrac,\r\n                        new Fraction(-b + nthDelta.coefficient, 2 * a).reduce().dfrac\r\n                    ]\r\n                }\r\n            }\r\n\r\n        } else if (delta === 0) {\r\n            this._solutions = [new Fraction(-b, 2 * a).reduce().dfrac];\r\n        } else {\r\n            this._solutions = [this._varnothing];\r\n        }\r\n\r\n\r\n        // Handle now the inequations.\r\n        if (!this.isStrictEqual()) {\r\n            if (this._solutions.length === 2) {\r\n                sX1 = (realX1 < realX2) ? this._solutions[0] : this._solutions[1];\r\n                sX2 = (realX1 < realX2) ? this._solutions[1] : this._solutions[0];\r\n\r\n                if ((this.isGreater() && aF.sign() === 1) || (!this.isGreater() && aF.sign() === -1)) {\r\n                    this._solutions = [\r\n                        `\\\\left]-\\\\infty ; ${sX1}\\\\right${this.isAlsoEqual() ? ']' : '['} \\\\cup \\\\left${this.isAlsoEqual() ? '[' : ']'}${sX2};+\\\\infty\\\\right[`\r\n                    ];\r\n                } else {\r\n                    this._solutions = [\r\n                        `\\\\left${this.isAlsoEqual() ? '[' : ']'}${sX1} ; ${sX2}\\\\right${this.isAlsoEqual() ? ']' : '['}`\r\n                    ]\r\n                }\r\n            } else if (this._solutions.length === 1 && this._solutions[0] !== this._varnothing) {\r\n                if (!this.isAlsoEqual()) {\r\n                    if ((this.isGreater() && aF.sign() === 1) || (!this.isGreater() && aF.sign() === -1)) {\r\n                        this._solutions = [\r\n                            `\\\\left]-\\\\infty ; ${this._solutions[0]}\\\\right[ \\\\cup \\\\left]${this._solutions[0]};+\\\\infty\\\\right[`\r\n                        ];\r\n                    } else {\r\n                        this._solutions = [this._varnothing];\r\n                    }\r\n                } else {\r\n                    if ((this.isGreater() && aF.sign() === 1) || (!this.isGreater() && aF.sign() === -1)) {\r\n                        this._solutions = [this._real];\r\n                    } else {\r\n                        // this._solutions = [ this._solutions[0] ];\r\n                    }\r\n                }\r\n            } else {\r\n                if (this.isGreater()) {\r\n                    this._solutions = [aF.sign() === 1 ? this._real : this._varnothing];\r\n                } else {\r\n                    this._solutions = [aF.sign() === -1 ? this._real : this._varnothing];\r\n                }\r\n            }\r\n        }\r\n        return this._solutions;\r\n    };\r\n\r\n    private _solveDegree3plus = (letter?: string): string[] => {\r\n        // TODO: try to resolve equations with a degree superior than 2.\r\n        this._solutions = [letter];  // ESLint remove system :(\r\n        return this._solutions;\r\n    };\r\n\r\n}","import {Fraction} from \"../coefficients/fraction\";\r\nimport {Equation} from \"./equation\";\r\nimport {Numeric} from \"../numeric\";\r\nimport {Monom} from \"./monom\";\r\nimport {Polynom} from \"./polynom\";\r\n\r\n\r\nexport class LinearSystem {\r\n    private _solutions: { [letter: string]: { value: Fraction, isReal: boolean, isVarnothing: boolean } };\r\n    private _resolutionSteps: LinearSystem[];\r\n    private _equations: Equation[];\r\n    private _letters: string[];\r\n\r\n    constructor(...equationStrings: string[]) {\r\n        this._equations = [];\r\n        this._letters = 'xy'.split('');\r\n\r\n        if(equationStrings!==undefined && equationStrings.length>0){\r\n            this.parse(...equationStrings);\r\n        }\r\n\r\n        return this;\r\n    }\r\n    get isLinerarSystem(){return true; }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get equations(): Equation[] {\r\n        return this._equations;\r\n    }\r\n\r\n    set equations(value) {\r\n        this._equations = value;\r\n    }\r\n\r\n    get letters(): string {return this._letters.join('')}\r\n\r\n    set letters(value:string){this._letters = value.split('');}\r\n\r\n    get isSolvable(): boolean {\r\n        let V = this.variables;\r\n\r\n        // TODO: in some case, it is possible to resolve systems if there isn't the isSame number of vars and equations\r\n        if (V.length !== this._equations.length) {\r\n            return false;\r\n        }\r\n\r\n        //TOOD: Must check if two equations isn't a linear combination of the others ?\r\n\r\n        return true;\r\n    }\r\n\r\n    get variables(): string[] {\r\n        let V: string[] = [];\r\n        for (let E of this._equations) {\r\n            V = V.concat(E.variables);\r\n        }\r\n        return [...new Set(V)].sort();\r\n    }\r\n\r\n    get tex(): string {\r\n        // Build the array of values.\r\n        // Reorder\r\n        // This clone the system :!!!\r\n        //TODO: Avoid cloning this linear system\r\n        let LS = this.clone().reorder(),\r\n            letters = LS.variables,\r\n            equStr: string[],\r\n            equArray: string[] = [],\r\n            m: Monom;\r\n\r\n        // TODO: Manage tex output of linear equations\r\n        for (let equ of LS.equations) {\r\n            equStr = [];\r\n            for (let L of letters) {\r\n                m = equ.left.monomByLetter(L);\r\n\r\n                if (equStr.length === 0) {\r\n                    equStr.push(m.isZero() ? '' : m.tex);\r\n                } else {\r\n                    equStr.push(m.isZero() ? '' : ((m.coefficient.sign() === 1) ? '+' : '') + m.tex);\r\n                }\r\n            }\r\n\r\n            // Add the equal sign\r\n            equStr.push('=');\r\n\r\n            // Add the right hand part of the equation (should be only a number, because it has been reorderd)\r\n            equStr.push(equ.right.tex);\r\n\r\n            // Add to the list.\r\n            equArray.push(equStr.join('&'));\r\n        }\r\n\r\n\r\n        return `\\\\left\\\\{\\\\begin{array}{${\"r\".repeat(letters.length)}cl}${equArray.join('\\\\\\\\\\ ')}\\\\end{array}\\\\right.`;\r\n        //return `\\\\left\\\\{\\\\begin{array}{rrrcl}${this._equations.map(equ => `${equ.tex}`).join('\\\\\\\\\\ \\n')}\\\\end{array}\\\\right.`;\r\n    }\r\n\r\n    get texSolution(): string {\r\n        let tex: string[] = [];\r\n\r\n        if (this._solutions === undefined) {\r\n            this.solve();\r\n        }\r\n\r\n        for (let letter in this._solutions) {\r\n            if (this._solutions[letter].isReal) {\r\n                console.log(`Undetermined (letter ${letter})`);\r\n                return;\r\n            }\r\n            if (this._solutions[letter].isVarnothing) {\r\n                console.log(`Undefined (letter ${letter})`);\r\n                return;\r\n            }\r\n\r\n            tex.push(this._solutions[letter].value.dfrac);\r\n        }\r\n        return `(${tex.join(';')})`;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    parse = (...equations: any[]): LinearSystem => {\r\n        this._equations = equations.map(value => new Equation(value));\r\n        this._findLetters();\r\n        return this;\r\n    };\r\n\r\n    setCoefficient = (...coefficients: string[]): LinearSystem => {\r\n        // Reset the equations list\r\n        this._equations = [];\r\n\r\n        let i = 0;\r\n        while (i < coefficients.length - this._letters.length) {\r\n            let left = new Polynom().parse(this._letters.join(''), ...coefficients.slice(i, i + this._letters.length)),\r\n                right = new Polynom(coefficients[i + this._letters.length].toString()),\r\n                equ = new Equation().create(left, right);\r\n            this._equations.push(equ.clone());\r\n\r\n            i = i + this._letters.length + 1;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    clone = (): LinearSystem => {\r\n        return new LinearSystem().parse(...this._equations.map(equ => equ.clone()));\r\n    };\r\n\r\n    setLetters = (...letters:string[]): LinearSystem => {\r\n        this._letters = letters;\r\n        return this\r\n    }\r\n    private _findLetters = (): LinearSystem => {\r\n        // Find all letters used.\r\n        let variables = new Set();\r\n\r\n        for(let equ of this._equations){\r\n            variables = new Set([...variables, ...equ.variables]);\r\n        }\r\n\r\n        // TODO: How to transform (Set of string) to string[]\r\n        // @ts-ignore\r\n        this._letters = [...variables];\r\n        return this;\r\n    }\r\n\r\n    // -----------------------------------------------\r\n    // Equations generators and randomizers\r\n    // -----------------------------------------------\r\n    generate = (...solutions: Fraction[] | number[]): LinearSystem => {\r\n        let solutionsF: Fraction[] = [];\r\n\r\n        // Convert the numbers to fractions if necessary\r\n        for (let s of solutions) {\r\n            if (typeof s === \"number\") {\r\n                solutionsF.push(new Fraction(s.toString()));\r\n            } else {\r\n                solutionsF.push(s.clone());\r\n            }\r\n        }\r\n\r\n        // Create the equations and make sure they are not linear combined.\r\n        this._equations = [];\r\n        for (let i = 0; i < solutions.length; i++) {\r\n            this._equations.push(this._generateOneEquation(...solutionsF));\r\n        }\r\n        return this;\r\n    };\r\n    private _generateOneEquation = (...solutions: Fraction[]): Equation => {\r\n        let coeff: number[] = [], leftValue: Fraction = new Fraction().zero(),\r\n            letters: string[] = ['x', 'y', 'z', 't', 'u', 'v', 'w', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l'],\r\n            equString: string = '', equ: Equation;\r\n        for (let i = 0; i < solutions.length; i++) {\r\n            coeff.push(Numeric.randomIntSym(5));\r\n            leftValue.add(solutions[i].clone().multiply(coeff[i]));\r\n            equString += `${(coeff[i] < 0) ? coeff[i] : '+' + coeff[i]}${letters[i]}`\r\n        }\r\n\r\n        // LeftValue contains the left part oof the equation - and is then the isSame as the right part.\r\n        // It might be a Fraction.\r\n\r\n        // Must check if it's not a linear combination\r\n        equ = new Equation(`${equString}=${leftValue.display}`);\r\n        if (equ.right.monoms[0].coefficient.denominator != 1) {\r\n            equ.multiply(new Fraction(equ.right.monoms[0].coefficient.denominator, 1));\r\n        }\r\n        if (this._checkIfLinerCombination(equ)) {\r\n            return equ;\r\n        } else {\r\n            return this._generateOneEquation(...solutions);\r\n        }\r\n    };\r\n\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    private _linearReduction(eq1: Equation, eq2: Equation, letter: string): Equation {\r\n        // TODO: handle other signs for equations ?\r\n        // Get the monom for the particular letter.\r\n        let c1 = eq1.left.monomByDegree(1, letter).coefficient.clone(),\r\n            c2 = eq2.left.monomByDegree(1, letter).coefficient.clone().opposed();\r\n\r\n        return this.mergeEquations(eq1, eq2, c2, c1);\r\n    }\r\n\r\n    mergeEquations = (eq1: Equation, eq2: Equation, factor1: any, factor2: any):Equation => {\r\n        // Set and clone the equations.\r\n\r\n        let eq1multiplied = eq1.clone().multiply(new Fraction(factor1)),\r\n            eq2multiplied = eq2.clone().multiply(new Fraction(factor2));\r\n\r\n        // Add both equations together.\r\n        eq1multiplied.left.add(eq2multiplied.left);\r\n        eq1multiplied.right.add(eq2multiplied.right);\r\n\r\n        return eq1multiplied;\r\n    }\r\n\r\n\r\n    // ------------------------------------------\r\n    // Solvers algorithm\r\n    // ------------------------------------------\r\n    reorder = (): LinearSystem => {\r\n        for (let E of this._equations) {\r\n            E.reorder();\r\n        }\r\n        return this;\r\n    };\r\n\r\n    solve = (): LinearSystem => {\r\n        // Solve it by linear\r\n        this._solutions = {};\r\n        this._resolutionSteps = [];\r\n\r\n        // Reorder all equations.\r\n        this.reorder();\r\n\r\n        // Get all variables in the linear system\r\n        let V = this.variables.sort();\r\n\r\n        for (let letter of V) {\r\n            this._solutions[letter] = this._solveOneLetter(letter, V)\r\n        }\r\n\r\n        // TODO: LinearSystem - solve: optimization and handle undetermined and undefined systems.\r\n        return this;\r\n    };\r\n\r\n    private _checkIfLinerCombination = (equ: Equation): boolean => {\r\n\r\n        return true;\r\n    };\r\n\r\n    private _solveOneLetter(letter: string, V: string[]): { value: Fraction, isReal: boolean, isVarnothing: boolean } {\r\n        // list of equations.\r\n        let LE: Equation[] = this.clone().equations,\r\n            reducedEquations: Equation[] = [];\r\n\r\n        // Reduce the equations.\r\n        // Do it as long as there is more than one step, but no more than the number of equations.\r\n        for (let L of V) {\r\n            // remove the setLetter from all equations using linear combinations\r\n            if (L === letter) {\r\n                continue;\r\n            }\r\n\r\n            // Linear reduction.\r\n            // TODO: Search for better association\r\n            for (let i = 0; i < LE.length - 1; i++) {\r\n                reducedEquations.push(this._linearReduction(LE[i], LE[i + 1], L));\r\n            }\r\n\r\n            // Keep track of each steps.\r\n            this._resolutionSteps.push(new LinearSystem().parse(...reducedEquations));\r\n\r\n            // Set the list of equations to the new version.\r\n            LE = this._resolutionSteps[this._resolutionSteps.length - 1].clone().equations;\r\n\r\n            // Reset the stack\r\n            reducedEquations = [];\r\n        }\r\n\r\n        // Solve the equations\r\n        let E = this._resolutionSteps[this._resolutionSteps.length - 1].equations[0];\r\n        E.solve();\r\n\r\n        return {\r\n            value: new Fraction(E.solutions[0]),\r\n            isReal: E.isReal,\r\n            isVarnothing: E.isVarnothing\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Helpers\r\n    // ------------------------------------------\r\n    log = (): string => {\r\n        let str: string = '';\r\n\r\n        for (let E of this._equations) {\r\n            console.log(E.tex);\r\n            str += `${E.tex}\\\\n}`;\r\n        }\r\n\r\n        return str;\r\n    };\r\n}","/***\r\n * Monom class\r\n * Defined as coefficient * literal\r\n * Examples: 3x^2, 3/5x^2, ...\r\n */\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Numeric} from \"../numeric\";\r\n\r\nexport class Monom {\r\n    private _coefficient: Fraction;\r\n    private _literal: { [Key: string]: number };\r\n\r\n    /**\r\n     * Create the monom object.\r\n     * @param value (optional) string\r\n     */\r\n    constructor(value?: unknown) {\r\n        this.zero();\r\n\r\n        if (value !== undefined) {\r\n            // A string is given - try to parse the value.\r\n            this.parse(value);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get isMonom() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get the coefficient as fraction\r\n     */\r\n    get coefficient(): Fraction {\r\n        return this._coefficient;\r\n    }\r\n\r\n    /**\r\n     * Set the coefficient value of the monom\r\n     * @param F     Fraction\r\n     */\r\n    set coefficient(F: Fraction) {\r\n        this._coefficient = F;\r\n    }\r\n\r\n    /**\r\n     * Get the literal part, as dictionary\r\n     */\r\n    get literal(): { [Key: string]: number } {\r\n        return this._literal;\r\n    }\r\n\r\n    get literalSqrt(): { [Key: string]: number } {\r\n\r\n        if (this.isLitteralSquare()) {\r\n            let L: { [Key: string]: number } = {}\r\n            for (let key in this._literal) {\r\n                L[key] = this._literal[key] / 2\r\n            }\r\n            return L;\r\n        } else {\r\n            return this._literal;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the literal part of the monom\r\n     * @param L     Literal part as dictionary: <setLetter: exposant>\r\n     */\r\n    set literal(L: { [Key: string]: number }) {\r\n        this._literal = L;\r\n    }\r\n\r\n    /**\r\n     * Set the literal part of the monom from a string\r\n     * @param inputStr  String like x^2y^3\r\n     */\r\n    set literalStr(inputStr: string) {\r\n        // Match all x^n\r\n        for (const v of [...inputStr.matchAll(/([a-z])\\^([+-]?[0-9]+)/g)]) {\r\n            if (!(v[1] in this._literal)) {\r\n                this._literal[v[1]] = 0;\r\n            }\r\n            this._literal[v[1]] += +v[2];\r\n        }\r\n        for (const v of [...inputStr.matchAll(/([a-z](?!\\^))/g)]) {\r\n            // Match all single letters\r\n            if (!(v[1] in this._literal)) {\r\n                this._literal[v[1]] = 0;\r\n            }\r\n            this._literal[v[1]] += 1;\r\n        }\r\n    }\r\n\r\n    // Getter heplers.\r\n    /**\r\n     * Get the variables letters\r\n     */\r\n    get variables(): string[] {\r\n        let M = this.clone().clean();\r\n        return Object.keys(this._literal)\r\n    }\r\n\r\n    // Display getter\r\n    /**\r\n     * This display getter is to be used in the polynom display getter\r\n     */\r\n    get display(): string {\r\n        let L: string = '';\r\n        for (let letter in this._literal) {\r\n            if (this._literal[letter] !== 0) {\r\n                L += `${letter}`;\r\n                if (this._literal[letter] > 1) {\r\n                    L += `^${this._literal[letter]}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (L === '') {\r\n            // No setLetter - means it's only a number !\r\n            if (this._coefficient.value != 0) {\r\n                return `${this._coefficient.display}`;\r\n            } else {\r\n                return '0';\r\n            }\r\n        } else {\r\n            if (this._coefficient.value === 1) {\r\n                return L;\r\n            } else if (this._coefficient.value === -1) {\r\n                return `-${L}`;\r\n            } else if (this._coefficient.value === 0) {\r\n                return '0';\r\n            } else {\r\n                return `${this._coefficient.display}${L}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    get dividers(): Monom[] {\r\n        // Decompose only if the coefficient it a complet value\r\n        if (this.coefficient.denominator !== 1) {\r\n            return [this.clone()]\r\n        }\r\n\r\n        // Security : do not do this if greater than 10000\r\n        if (this.coefficient.numerator > 10000) {\r\n            return [this.clone()]\r\n        }\r\n        const dividers = Numeric.dividers(Math.abs(this.coefficient.numerator))\r\n\r\n        // Decompose the litterals parts.\r\n        let litterals: { [key: string]: number }[] = [];\r\n        for (let L in this.literal) {\r\n            // L is the letter.\r\n            litterals = this._getLitteralDividers(litterals, L)\r\n        }\r\n\r\n        const monomDividers: Monom[] = [];\r\n        if (litterals.length > 0 && dividers.length > 0) {\r\n            for (let N of dividers) {\r\n                for (let L of litterals) {\r\n                    let M = new Monom();\r\n                    M.coefficient = new Fraction(N)\r\n                    M.literal = L\r\n                    monomDividers.push(M)\r\n                }\r\n            }\r\n        } else if (dividers.length === 0) {\r\n            for (let L of litterals) {\r\n                let M = new Monom();\r\n                M.coefficient = new Fraction().one()\r\n                M.literal = L\r\n                monomDividers.push(M)\r\n            }\r\n        } else {\r\n            for (let N of dividers) {\r\n                let M = new Monom();\r\n                M.coefficient = new Fraction(N)\r\n                monomDividers.push(M)\r\n            }\r\n        }\r\n\r\n        return monomDividers.length === 0 ? [new Monom().one()] : monomDividers;\r\n    }\r\n\r\n    private _getLitteralDividers(arr: { [key: string]: number }[], letter: string): { [key: string]: number }[] {\r\n        let tmpList: { [key: string]: number }[] = [];\r\n\r\n        for (let d = 0; d <= this.literal[letter]; d++) {\r\n            if (arr.length === 0) {\r\n                let litt: { [key: string]: number } = {}\r\n                litt[letter] = d\r\n                tmpList.push(litt)\r\n            } else {\r\n                for (let item of arr) {\r\n                    let litt: { [key: string]: number } = {}\r\n                    for (let currentLetter in item) {\r\n                        litt[currentLetter] = item[currentLetter]\r\n                    }\r\n                    litt[letter] = d\r\n                    tmpList.push(litt)\r\n                }\r\n            }\r\n        }\r\n        return tmpList;\r\n    }\r\n\r\n    /**\r\n     * Display the monom, forcing the '+' sign to appear\r\n     */\r\n    get displayWithSign(): string {\r\n        // TODO: Rename or remove this getter ?\r\n        let d: String = this.display;\r\n        return (d[0] !== '-' ? '+' : '') + d;\r\n    }\r\n\r\n    /**\r\n     * Get the tex output of the monom\r\n     */\r\n    get tex(): string {\r\n        let L: string = '';\r\n        for (let letter in this._literal) {\r\n            if (this._literal[letter] !== 0) {\r\n                L += `${letter}`;\r\n                if (this._literal[letter] > 1) {\r\n                    L += `^${this._literal[letter]}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (L === '') {\r\n            // No setLetter - means it's only a number !\r\n            if (this._coefficient.value != 0) {\r\n                return `${this._coefficient.dfrac}`;\r\n            } else {\r\n                return '0';\r\n            }\r\n        } else {\r\n            if (this._coefficient.value === 1) {\r\n                return L;\r\n            } else if (this._coefficient.value === -1) {\r\n                return `-${L}`;\r\n            } else if (this._coefficient.value === 0) {\r\n                return '0';\r\n            } else {\r\n                return `${this._coefficient.dfrac}${L}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // -----------------------------------------\r\n    /**\r\n     * Parse a string to a monom. The string may include fraction.\r\n     * @param inputStr\r\n     */\r\n    parse = (inputStr: unknown): Monom => {\r\n        if (typeof inputStr === 'string') {\r\n            // Set the literal part.\r\n            this.literalStr = inputStr;\r\n\r\n            // Get the coefficient\r\n            this._coefficient = new Fraction();\r\n\r\n            for (const v of [...inputStr.replace(/([a-z])|(\\^[+-]?[0-9]+)/g, ',').split(',')]) {\r\n                // The value is empty.\r\n                if (v.trim() === '') {\r\n                    continue;\r\n                }\r\n\r\n                // Multiple the current coefficient by the new found value.\r\n                this._coefficient.multiply(new Fraction(v.trim()));\r\n            }\r\n        } else if (typeof inputStr === 'number') {\r\n            this._coefficient = new Fraction(inputStr)\r\n        } else if (typeof inputStr === 'object' && inputStr instanceof Fraction) {\r\n            this._coefficient = inputStr.clone()\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Clone the current Monom.\r\n     */\r\n    clone = (): Monom => {\r\n        let F: Monom = new Monom();\r\n\r\n        F.coefficient = this._coefficient.clone();\r\n\r\n        // Copy the literal parts.\r\n        for (let k in this._literal) {\r\n            F.setLetter(k, this._literal[k]);\r\n        }\r\n        return F;\r\n    };\r\n\r\n    /**\r\n     * Create a zero value monom\r\n     */\r\n    zero = (): Monom => {\r\n        this._coefficient = new Fraction().zero();\r\n        this._literal = {};\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Create a one value monom\r\n     */\r\n    one = (): Monom => {\r\n        this._coefficient = new Fraction().one();\r\n        this._literal = {};\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Clean the monom by removing each letters with a power of zero.\r\n     */\r\n    clean = (): Monom => {\r\n        for (let letter in this._literal) {\r\n            if (this._literal[letter] === 0) {\r\n                delete this._literal[letter];\r\n            }\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Generate a random monom\r\n     * @param letters       Letters to use, as a string\r\n     * @param degree        Max degree (default 1)\r\n     * @param withFraction  Allows fraction as coefficient (default false)\r\n     * @param allowZero     Allows null monom (default false)\r\n     */\r\n    random = (letters: string = 'x', degree: number = 1, withFraction: boolean = false, allowZero: boolean = false): Monom => {\r\n        // TODO: Randomize monoms: options or make it subclass ?\r\n        this.coefficient.parse(Numeric.randomIntSym(10, allowZero), (withFraction) ? Numeric.randomInt(1, 10) : 1);\r\n\r\n        for (let L of letters.split('')) {\r\n            this.setLetter(L, (letters.length > 1) ? Numeric.randomInt(degree) : degree);\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n\r\n    /**\r\n     * Get the opposed\r\n     * Returns a monom.\r\n     */\r\n    opposed = (): Monom => {\r\n        this._coefficient.opposed();\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Add all similar monoms. If they aren't similar, they are simply skipped.\r\n     * @param M (Monom[]) The monoms to add.\r\n     */\r\n    add = (...M: Monom[]): Monom => {\r\n        for (let m of M) {\r\n            if (this.isSameAs(m)) {\r\n                this._coefficient.add(m.coefficient);\r\n            } else {\r\n                console.log('Add: Is not similar: ', m.display);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Subtract multiple monoms\r\n     * @param M (Monom[]) The monoms to subtract\r\n     */\r\n    subtract = (...M: Monom[]): Monom => {\r\n        for (let m of M) {\r\n            if (this.isSameAs(m)) {\r\n                this._coefficient.add(m.coefficient.clone().opposed());\r\n            } else {\r\n                console.log('Subtract: Is not similar: ', m.display);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Multiple multiple monoms to the current monom\r\n     * @param M (Monom[]) The monoms to multiply to.\r\n     */\r\n    multiply = (...M: Monom[]): Monom => {\r\n        for (let m of M) {\r\n            // Multiply the coefficient.\r\n            this._coefficient.multiply(m.coefficient);\r\n            // Multiply the literal parts.\r\n            for (let letter in m.literal) {\r\n                this._literal[letter] = (this._literal[letter] === undefined) ? m.literal[letter] : this._literal[letter] + m.literal[letter];\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    multiplyByNumber = (F: Fraction | number): Monom => {\r\n        this._coefficient.multiply(F);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Divide the current monoms by multiple monoms\r\n     * @param M (Monom[])\r\n     */\r\n    divide = (...M: Monom[]): Monom => {\r\n        // Depending on the given value, choose the current item\r\n        for (let v of M) {\r\n            // Divide the coefficient\r\n            this._coefficient.divide(v.coefficient);\r\n\r\n            // Subtract the power values\r\n            for (let letter in v.literal) {\r\n                this._literal[letter] = (this._literal[letter] === undefined) ? -v.literal[letter] : this._literal[letter] - v.literal[letter];\r\n\r\n                // If the power of a particular setLetter is zero, delete it from the literal part..\r\n                if (this._literal[letter] === 0) {\r\n                    delete this._literal[letter];\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Get the pow of a monom.\r\n     * @param nb (number) : Mathematical pow\r\n     */\r\n    pow = (nb: number): Monom => {\r\n        this._coefficient.pow(nb);\r\n        for (let letter in this._literal) {\r\n            this._literal[letter] *= nb;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Get the nth-root of the monom\r\n     * @param p\r\n     */\r\n    root = (p: number): Monom => {\r\n        // TODO: determiner the nth root of a monom\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Return the square root of a monom\r\n     */\r\n    sqrt = (): Monom => {\r\n        if (this.isSquare()) {\r\n            this._coefficient.sqrt();\r\n            for (let letter in this._literal) {\r\n                this._literal[letter] /= 2;\r\n            }\r\n        }\r\n        return this.root(2);\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Compare functions\r\n    // ------------------------------------------\r\n    compare = (M: Monom, sign?: string): boolean => {\r\n        // TODO: Build the compare systems.\r\n        if (sign === undefined) {\r\n            sign = '=';\r\n        }\r\n\r\n\r\n        switch (sign) {\r\n            case '=':\r\n                // To be equal, they must be the isSame\r\n                if (!this.compare(M, 'same')) {\r\n                    return false;\r\n                }\r\n\r\n                // The litteral parts are the isSame. The coefficient must be equal\r\n                return this._coefficient.isEqual(M.coefficient);\r\n            case 'same':\r\n                // Get the list of all variables from both monoms.\r\n                let M1: string[] = this.variables,\r\n                    M2: string[] = M.variables,\r\n                    K: string[] = M1.concat(M2.filter((item) => M1.indexOf(item) < 0));\r\n\r\n                for (let key of K) {\r\n                    // The setLetter is not available in one of the monom\r\n                    if (this._literal[key] === undefined || M.literal[key] === undefined) {\r\n                        return false;\r\n                    }\r\n                    // The setLetter does not have the isSame power in each monoms.\r\n                    if (this._literal[key] !== M.literal[key]) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                // All are positive check - the monoms are the sames.\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine if the monom is null\r\n     */\r\n    isZero(): boolean {\r\n        return this._coefficient.value === 0;\r\n    }\r\n\r\n    /**\r\n     * Determine if the monom is one\r\n     */\r\n    isOne(): boolean {\r\n        return this._coefficient.value === 1 && this.variables.length === 0;\r\n    }\r\n\r\n    /**\r\n     * Determine if two monoms are equals\r\n     * @param M\r\n     */\r\n    isEqual = (M: Monom): boolean => {\r\n        return this.compare(M, '=');\r\n    };\r\n\r\n    /**\r\n     * Determine if two monoms are similar\r\n     * @param M\r\n     */\r\n    isSameAs = (M: Monom): boolean => {\r\n        return this.compare(M, 'same');\r\n    };\r\n\r\n    isSquare = (): boolean => {\r\n        if (!this.coefficient.isSquare()) {\r\n            return false;\r\n        }\r\n        return this.isLitteralSquare();\r\n    }\r\n\r\n    isLitteralSquare = (): boolean => {\r\n        for (let letter in this.literal) {\r\n            if (this.literal[letter] % 2 !== 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    // ------------------------------------------\r\n    // Misc monoms functions\r\n    // -------------------------------------\r\n    /**\r\n     * Determine if a monom contains a setLetter in it's literal part\r\n     * @param letter\r\n     */\r\n    hasLetter = (letter?: string): boolean => {\r\n        return this._literal[letter === undefined ? 'x' : letter] > 0;\r\n    };\r\n\r\n    /**\r\n     * Set the power of a particular setLetter\r\n     * @param letter (string) Letter to change\r\n     * @param pow (number) Power of the setLetter (must be positive integer.\r\n     */\r\n    setLetter = (letter: string, pow: number): void => {\r\n        // If the power is not legal or is zero, remove the setLetter from the dict\r\n        if (pow <= 0 || !Number.isSafeInteger(pow)) {\r\n            if (this._literal[letter] !== undefined) {\r\n                delete this._literal[letter];\r\n            }\r\n        } else {\r\n            this._literal[letter] = pow;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Get the degree of a monom. If no setLetter is given, the result will be the global degree.\r\n     * @param letter (string) Letter to get to degree (power)\r\n     */\r\n    degree = (letter?: string): number => {\r\n        if (this.variables.length === 0) {\r\n            return 0;\r\n        }\r\n        if (letter === undefined) {\r\n            // Not setLetter given -> we get the global monom degree (sum of all the letters).\r\n            return Object.values(this._literal).reduce((t, n) => t + n);\r\n        } else {\r\n            // A setLetter is given -> get the corresponding power.\r\n            return this._literal[letter] === undefined ? 0 : this._literal[letter];\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Evaluate a monom. Each setLetter must be assigned to a Fraction.\r\n     * @param values    Dictionary of <setLetter: Fraction>\r\n     */\r\n    evaluate = (values: { [key: string]: Fraction }): Fraction => {\r\n        let r = this.coefficient.clone();\r\n\r\n        for (let L in this._literal) {\r\n            if (values[L] === undefined) {\r\n                return new Fraction().zero();\r\n            }\r\n            r.multiply(values[L].clone().pow(this._literal[L]));\r\n        }\r\n        return r;\r\n    };\r\n\r\n    /**\r\n     * Derivative the monom\r\n     * @param letter\r\n     */\r\n    derivative = (letter?: string): Monom => {\r\n        // No setLetter given - assume it's the setLetter 'x'\r\n        if (letter === undefined) {\r\n            letter = 'x';\r\n        }\r\n        if (this.hasLetter(letter)) {\r\n            let d = +this._literal[letter],\r\n                dM = this.clone();\r\n\r\n            // Subtract one to the degree.\r\n            dM._literal[letter] -= 1;\r\n\r\n            // Multiply the coefficient by the previous degree\r\n            dM._coefficient.multiply(new Fraction('' + d));\r\n            return dM;\r\n        } else {\r\n            return new Monom().zero();\r\n        }\r\n    };\r\n\r\n    // ----------------------------------------\r\n    // Static functions\r\n    // ----------------------------------------\r\n\r\n    /**\r\n     * Get the least common multiple of monoms\r\n     * @param monoms    Array of monoms\r\n     */\r\n    static lcm = (...monoms: Monom[]): Monom => {\r\n        let M = new Monom(),\r\n            coeffN: number[] = monoms.map(value => value.coefficient.numerator),\r\n            coeffD: number[] = monoms.map(value => value.coefficient.denominator),\r\n            n = Numeric.gcd(...coeffN),\r\n            d = Numeric.lcm(...coeffD);\r\n\r\n        // Get the coefficient.\r\n        M.coefficient = new Fraction(n, d).reduce();\r\n\r\n        // Set the literal parts - go through each monoms literal parts and get only the lowest degree of each letters.\r\n        for (let m of monoms) {\r\n            // Remove the inexistant letters from the resulting monom\r\n            for (let letter in M.literal) {\r\n                if (!(letter in m.literal)) {\r\n                    M.literal[letter] = 0;\r\n                }\r\n            }\r\n            for (let letter in m.literal) {\r\n                if (M.literal[letter] === undefined && m.literal[letter] > 0) {\r\n                    M.literal[letter] = m.literal[letter];\r\n                } else {\r\n                    M.literal[letter] = Math.min(m.literal[letter], M.literal[letter]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return M;\r\n    };\r\n\r\n    /**\r\n     * Multiply two monoms and return a NEW monom.\r\n     * @param M1\r\n     * @param M2\r\n     */\r\n    static xmultiply = (...monoms: Monom[]): Monom => {\r\n        let M = new Monom().one();\r\n\r\n        for (let m of monoms) {\r\n            M.multiply(m);\r\n        }\r\n\r\n        return M;\r\n    };\r\n\r\n\r\n    // TODO: The rest of the functions are not used or unnecessary ?\r\n    /**\r\n     * Determine if multiple monoms are similar\r\n     * @param M\r\n     */\r\n    areSameAs = (...M: Monom[]): boolean => {\r\n        let result: boolean = true;\r\n\r\n        // Check all monoms if they are the isSame as the \"this\" one.\r\n        for (let i = 0; i < M.length; i++) {\r\n            if (!this.isSameAs(M[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // All check passed -> all the monoms are similar.\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Determine if multiple monoms are equals\r\n     * @param M\r\n     */\r\n    areEquals = (...M: Monom[]): boolean => {\r\n        // They are not similar.\r\n        if (!this.areSameAs(...M)) {\r\n            return false;\r\n        }\r\n\r\n        // Check all coefficient. They must be equals.\r\n        for (let m of M) {\r\n            if (!this._coefficient.isEqual(m.coefficient)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // All checks passed.\r\n        return true;\r\n    };\r\n\r\n}","/**\r\n * Polynom module contains everything necessary to handle polynoms.\r\n * @module Polynom\r\n */\r\n\r\nimport {Monom} from './monom';\r\nimport {Shutingyard} from '../shutingyard';\r\nimport {Numeric} from '../numeric';\r\nimport {Fraction} from '../coefficients/fraction';\r\n\r\n/**\r\n * Polynom class can handle polynoms, reorder, resolve, ...\r\n */\r\nexport class Polynom {\r\n    private _rawString: string;\r\n    private _monoms: Monom[];\r\n    private _factors: Polynom[];\r\n    private _texString: string;\r\n\r\n    /**\r\n     *\r\n     * @param {string} polynomString (optional) Default polynom to parse on class creation\r\n     * @param values\r\n     */\r\n    constructor(polynomString?: string, ...values: unknown[]) {\r\n        this._monoms = [];\r\n        this._factors = [];\r\n        if (polynomString !== undefined) {\r\n            this.parse(polynomString, ...values);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    get isPolynom() {\r\n        return true;\r\n    };\r\n\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get monoms() {\r\n        return this._monoms;\r\n    }\r\n\r\n    set monoms(M: Monom[]) {\r\n        this._monoms = M;\r\n    }\r\n\r\n    get factors(): Polynom[] {\r\n        if(this._factors.length===0){this.factorize()}\r\n        return this._factors;\r\n    }\r\n\r\n    set factors(value: Polynom[]) {\r\n        this._factors = value;\r\n    }\r\n\r\n    get texFactors(): string {\r\n        this.factorize()\r\n\r\n        let tex = ''\r\n        for (let f of this.factors) {\r\n            if (f.monoms.length > 1) {\r\n                tex += `(${f.tex})`\r\n            } else {\r\n                tex = f.tex + tex;\r\n            }\r\n        }\r\n        return tex;\r\n    }\r\n\r\n    get texString(): string {\r\n        return this._texString;\r\n    }\r\n\r\n    get length() {\r\n        return this._monoms.filter(x=>!x.coefficient.isZero).length;\r\n    }\r\n\r\n    get display(): string {\r\n        return this.genDisplay();\r\n    }\r\n\r\n    get raw(): string {\r\n        return this._rawString\r\n    }\r\n\r\n    get tex(): string {\r\n        return this.genDisplay('tex');\r\n    }\r\n\r\n    get isMultiVariable(): boolean {\r\n        const B = false;\r\n        for (const m of this._monoms) {\r\n            if (m.variables.length > 1) {\r\n                return true;\r\n            }\r\n        }\r\n        return B;\r\n    }\r\n\r\n    get variables(): string[] {\r\n        let V: string[] = [];\r\n\r\n        for (const m of this._monoms) {\r\n            V = V.concat(m.variables);\r\n        }\r\n\r\n        // Remove duplicates.\r\n        V = [...new Set(V)];\r\n\r\n        return V;\r\n    }\r\n\r\n    get numberOfVars(): number {\r\n        return this.variables.length;\r\n    }\r\n\r\n    private genDisplay = (output?: string, forceSign?: boolean, wrapParentheses?: boolean): string => {\r\n        let P: string = '';\r\n\r\n        for (const k of this._monoms) {\r\n            if (k.coefficient.value === 0) {\r\n                continue;\r\n            }\r\n\r\n            P += `${(k.coefficient.sign() === 1 && (P !== '' || forceSign === true)) ? '+' : ''}${(output === 'tex') ? k.tex : k.display}`;\r\n        }\r\n\r\n        if (wrapParentheses === true && this.length > 1) {\r\n            if (output === 'tex') {\r\n                P = `\\\\left( ${P} \\\\right)`;\r\n            } else {\r\n                P = `(${P})`;\r\n            }\r\n        }\r\n\r\n        if (P === '') {\r\n            P = '0';\r\n        }\r\n        return P;\r\n    };\r\n\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    /**\r\n     * Parse a string to a polynom.\r\n     * @param inputStr\r\n     * @param values: as string, numbers or fractions\r\n     */\r\n    parse = (inputStr: string, ...values: unknown[]): Polynom => {\r\n        if (values === undefined || values.length === 0) {\r\n            inputStr = '' + inputStr;\r\n            this._rawString = inputStr;\r\n\r\n            // Parse the polynom using the shuting yard algorithm\r\n            if (inputStr !== '' && !isNaN(Number(inputStr))) {\r\n                this.empty();\r\n                // It's a simple number.\r\n                let m = new Monom();\r\n                m.coefficient = new Fraction(inputStr);\r\n                m.literalStr = '';\r\n                this.add(m);\r\n                return this;\r\n            }\r\n\r\n            // Parse the string.\r\n            return this.shutingYardToReducedPolynom(inputStr);\r\n        } else if (/^[a-z]/.test(inputStr)) {\r\n            // We assume the inputStr contains only letters.\r\n            this.empty();\r\n\r\n            let fractions = values.map(x => new Fraction(x));\r\n            // Multiple setLetter version\r\n            if (inputStr.length > 1) {\r\n                // TODO: check that the number of values given correspond to the letters (+1 eventually)\r\n                let letters = inputStr.split(''),\r\n                    i = 0;\r\n                for (let F of fractions) {\r\n                    let m = new Monom();\r\n                    m.coefficient = F.clone();\r\n                    m.literalStr = letters[i] || '';\r\n                    this.add(m);\r\n                    i++;\r\n                }\r\n            }\r\n            // Single setLetter version\r\n            else {\r\n                let n = fractions.length - 1;\r\n                for (let F of fractions) {\r\n                    let m = new Monom()\r\n                    m.coefficient = F.clone();\r\n                    m.literalStr = `${inputStr}^${n}`\r\n                    this.add(m);\r\n                    n--;\r\n                }\r\n            }\r\n            return this;\r\n        } else {\r\n            return this.zero();\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * Main parse using a shutting yard class\r\n     * @param inputStr\r\n     */\r\n    private shutingYardToReducedPolynom = (inputStr: string): Polynom => {\r\n        // Get the RPN array of the current expression\r\n        const SY: Shutingyard = new Shutingyard().parse(inputStr);\r\n        const rpn: string[] = SY.rpn;\r\n        const m: Polynom[] = [];\r\n        let m1: Polynom;\r\n        let m2: Polynom;\r\n        let tokenParam: number = null;\r\n\r\n        for (const token of rpn) {\r\n            if (SY.isOperation(token)) {\r\n                // Polynom\r\n                m2 = (m.pop()) || new Polynom().zero();\r\n\r\n                if (token[0] !== '^') {\r\n                    if (m.length > 0) {\r\n                        // Get the first item from the stack\r\n                        m1 = (m.pop()) || new Polynom().zero();\r\n                    } else {\r\n                        // Nothing is in the stack - create an empty polynom\r\n                        m1 = new Polynom().zero();\r\n                    }\r\n                } else {\r\n                    // tokenParam = parseInt(token.split('^')[1]);\r\n                    tokenParam = Number(token.substr(1));\r\n                    // m2.clone().pow(tokenParam);\r\n                }\r\n\r\n\r\n                switch (token) {\r\n                    case '+':\r\n                        m1.add(m2);\r\n                        break;\r\n                    case '-':\r\n                        m1.subtract(m2);\r\n                        break;\r\n                    case '*':\r\n                        m1.multiply(m2);\r\n                        break;\r\n                    // TODO: Shuting yard to polynom divide.\r\n                    // case '/': console.log(m1.display, m2.display);m1.divide(m2); break;\r\n                    // By default, all not operation value are converted to polynom. Therefore, the pow value must be converted to an integer.\r\n                    // TODO: Shuting yard to polynom pow : case '^': m1.pow(+m2.monoms[0].coefficient.numerator); break;\r\n                    default:\r\n                        if (tokenParam !== null) {\r\n                            if (token[0] === '^') {\r\n                                m1 = m2.clone().pow(tokenParam);\r\n                            }\r\n                        } else {\r\n                            console.log('Token not recognized in shuting yard to reduce polynom: ', token);\r\n                        }\r\n                }\r\n                m.push(m1);\r\n            } else {\r\n                // console.log('NOT OPERATION: ', token, new Monom(token).tex)\r\n                m.push(new Polynom().add(new Monom(token)));\r\n            }\r\n        }\r\n\r\n        this._monoms = m[0].monoms;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clone the polynom\r\n     */\r\n    clone = (): Polynom => {\r\n        const P = new Polynom();\r\n        const M: Monom[] = [];\r\n\r\n        for (const m of this._monoms) {\r\n            M.push(m.clone());\r\n        }\r\n\r\n        P.monoms = M;\r\n        return P;\r\n    };\r\n\r\n    /**\r\n     * Set the polynom to zero.\r\n     * @returns {this}\r\n     */\r\n    zero = (): Polynom => {\r\n        this._monoms = [];\r\n        this._monoms.push(new Monom().zero());\r\n        this._rawString = '0';\r\n        return this;\r\n    };\r\n\r\n    one = (): Polynom => {\r\n        this._monoms = [];\r\n        this._monoms.push(new Monom().one());\r\n        this._rawString = '1';\r\n        return this;\r\n    }\r\n\r\n    empty = (): Polynom => {\r\n        this._monoms = [];\r\n        this._rawString = '';\r\n        return this;\r\n    };\r\n\r\n    // -----------------------------------------------\r\n    // Polynom generators and randomizers\r\n    // -----------------------------------------------\r\n    private _randomizeDefaults: { [key: string]: number | string | boolean } = {\r\n        degree: 2,\r\n        unit: true,\r\n        fractions: false,\r\n        factorable: false,\r\n        letters: 'x',\r\n        allowNullMonom: false,\r\n        numberOfMonoms: false\r\n    };\r\n    get randomizeDefaults(): { [key: string]: number | string | boolean } {\r\n        return this._randomizeDefaults;\r\n    }\r\n\r\n    set randomizeDefaults(value) {\r\n        this._randomizeDefaults = value;\r\n    }\r\n\r\n    randomize = (config: { [key: string]: number | string | boolean }): Polynom => {\r\n        let P = new Polynom();\r\n\r\n        // Check the config file and use the default values.\r\n        if (config === undefined) {\r\n            config = {};\r\n        }\r\n        for (let k in this._randomizeDefaults) {\r\n            if (config[k] === undefined) {\r\n                config[k] = this._randomizeDefaults[k];\r\n            }\r\n        }\r\n\r\n        // TODO: Build a more robust randomize function\r\n        return P;\r\n    }\r\n\r\n\r\n    // TODO: Remove rndSimple and rndFactorable.\r\n    /**\r\n     * Polynom generator\r\n     * @param degree\r\n     * @param unit\r\n     * @param withFraction\r\n     * @param letters\r\n     * @param allowZero\r\n     * @param numberOfMonoms\r\n     */\r\n    rndSimple = (degree: number = 1, unit: boolean = false, withFraction: boolean = false, letters: string = 'x', allowZero: boolean = true, numberOfMonoms: number = -1): Polynom => {\r\n        // TODO: Make rndSimple polynom generator more user friendly\r\n        // If the current polynom (this) is already created, initialise it!\r\n        this.empty();\r\n\r\n        let M: Monom;\r\n        for (let i = degree; i >= 0; i--) {\r\n            M = new Monom().random(letters, i, withFraction, (i === degree) ? false : allowZero);\r\n\r\n            // We want to have the greatest degree monom coefficient to be unit.\r\n            if (unit && i === degree) {\r\n                M.coefficient = new Fraction().one();\r\n            }\r\n            this.add(M);\r\n        }\r\n\r\n        // Remove randomly the monoms to match the number of monoms.\r\n        if (numberOfMonoms > 0 && numberOfMonoms < this.length) {\r\n            this.reorder();\r\n            // Keep the greatest degree monom.\r\n            // But remove randomly the next monoms.\r\n            while (this.length > numberOfMonoms) {\r\n                this._monoms.splice(Numeric.randomInt(1, this.length - 1), 1);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    rndFactorable = (degree: number = 2, unit: boolean | number = false, letters: string = 'x'): Polynom => {\r\n        // TODO: Make rndFactorable polynom generator more user friendly\r\n        this._factors = [];\r\n        for (let i = 0; i < degree; i++) {\r\n            let factorUnit = unit === true || i >= unit,\r\n                p = new Polynom().rndSimple(1, factorUnit, false, letters);\r\n\r\n            this._factors.push(p);\r\n        }\r\n\r\n        this.empty().monoms = this._factors[0].monoms;\r\n        for (let i = 1; i < this._factors.length; i++) {\r\n            this.multiply(this._factors[i]);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    opposed = (): Polynom => {\r\n        this._monoms = this._monoms.map(m => m.opposed());\r\n        return this;\r\n    };\r\n\r\n    add = (...values: unknown[]): Polynom => {\r\n\r\n        for (let value of values) {\r\n            if(typeof value==='object'){\r\n                if (value instanceof Polynom) {\r\n                    this._monoms = this._monoms.concat(value.monoms);\r\n                } else if (value instanceof Monom) {\r\n                    this._monoms.push(value.clone());\r\n                }\r\n            }else {\r\n                this._monoms.push(new Monom(value));\r\n            }\r\n        }\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    subtract = (...values: unknown[]): Polynom => {\r\n\r\n        for (let value of values) {\r\n            if(typeof value==='object') {\r\n                if (value instanceof Polynom) {\r\n                    this._monoms = this._monoms.concat(value.clone().opposed().monoms);\r\n                } else if (value instanceof Monom) {\r\n                    this._monoms.push(value.clone().opposed());\r\n                }\r\n            }else {\r\n                this._monoms.push(new Monom(value).opposed());\r\n            }\r\n        }\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    multiply = (value: unknown): Polynom => {\r\n        if(typeof value === 'object'){\r\n            if (value instanceof Polynom) {\r\n                return this.multiplyByPolynom(value);\r\n            } else if (value instanceof Fraction) {\r\n                return this.multiplyByFraction(value);\r\n            } else if (value instanceof Monom) {\r\n                return this.multiplyByMonom(value);\r\n            }\r\n        } else if (typeof value==='number' && Number.isSafeInteger(value)) {\r\n            return this.multiplyByInteger(value);\r\n        }\r\n\r\n        // Something went wrong...\r\n        return this;\r\n    }\r\n\r\n    private multiplyByPolynom = (P: Polynom): Polynom => {\r\n        const M: Monom[] = [];\r\n        for (const m1 of this._monoms) {\r\n            for (const m2 of P.monoms) {\r\n                M.push(Monom.xmultiply(m1, m2));\r\n            }\r\n        }\r\n\r\n        this._monoms = M;\r\n        return this.reduce();\r\n    };\r\n\r\n    private multiplyByFraction = (F: Fraction): Polynom => {\r\n        for (const m of this._monoms) {\r\n            m.coefficient.multiply(F);\r\n        }\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    private multiplyByInteger = (nb: number): Polynom => {\r\n        return this.multiplyByFraction(new Fraction(nb));\r\n    };\r\n\r\n    private multiplyByMonom = (M: Monom): Polynom => {\r\n        for (const m of this._monoms) {\r\n            m.multiply(M)\r\n        }\r\n        return this.reduce();\r\n    };\r\n\r\n    /**\r\n     * Divide the current polynom by another polynom.\r\n     * @param P\r\n     * returns {quotient: Polynom, reminder: Polynom}\r\n     */\r\n    euclidian = (P: Polynom): { quotient: Polynom, reminder: Polynom } => {\r\n        const letter: string = P.variables[0];\r\n        const quotient: Polynom = new Polynom().zero();\r\n        const reminder: Polynom = this.clone().reorder(letter);\r\n\r\n        // There is no variable !\r\n        if (P.variables.length === 0) {\r\n            return {quotient, reminder}\r\n        }\r\n\r\n        // Get at least a letter\r\n\r\n        const maxMP: Monom = P.monomByDegree(undefined, letter);\r\n        const degreeP: number = P.degree(letter);\r\n\r\n        let newM: Monom;\r\n\r\n        // Make the euclidian division of the two polynoms.\r\n        let MaxIteration = this.degree(letter) * 2;\r\n        while (reminder.degree(letter) >= degreeP && MaxIteration >= 0) {\r\n            // console.log('EUCLIDE Q', quotient.degree(letter), quotient.tex)\r\n            // console.log('EUCLIDE R', reminder.degree(letter), reminder.tex)\r\n            // console.log('ITERATION', MaxIteration)\r\n            MaxIteration--\r\n\r\n            // Get the greatest monom divided by the max monom of the divider\r\n            newM = reminder.monomByDegree(undefined, letter).clone().divide(maxMP);\r\n\r\n            if (newM.isZero()) {\r\n                break;\r\n            }\r\n\r\n            // Get the new quotient and reminder.\r\n            quotient.add(newM);\r\n            reminder.subtract(P.clone().multiply(newM));\r\n        }\r\n\r\n        return {quotient, reminder};\r\n    };\r\n\r\n    divide = (value: unknown): Polynom => {\r\n        if (typeof value==='number' && Number.isSafeInteger(value)) {\r\n            return this.divideByInteger(value);\r\n        } else if (typeof value === 'object' && value instanceof Fraction) {\r\n            this.divideByFraction(value);\r\n        }\r\n    }\r\n\r\n    private divideByInteger = (nb: number): Polynom => {\r\n        const nbF = new Fraction(nb);\r\n        for (const m of this._monoms) {\r\n            m.coefficient.divide(nbF);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    private divideByFraction = (F: Fraction): Polynom => {\r\n        for (const m of this._monoms) {\r\n            m.coefficient.divide(F);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    pow = (nb: number): Polynom => {\r\n        if (!Number.isSafeInteger(nb)) {\r\n            return this.zero();\r\n        }\r\n        if (nb < 0) {\r\n            return this.zero();\r\n        }\r\n        if (nb === 0) {\r\n            return new Polynom();\r\n        }\r\n\r\n        const P = this.clone();\r\n        for (let i = 1; i < nb; i++) {\r\n            this.multiply(P);\r\n        }\r\n        return this.reduce();\r\n    };\r\n\r\n\r\n    // ------------------------------------------\r\n    // Compare functions\r\n    // ------------------------------------------\r\n    /**\r\n     * Compare the current coefficient with another coefficient\r\n     * @param F (Coefficient) The coefficient to compare\r\n     * @param sign (string| default is =): authorized values: =, <, <=, >, >= with some variations.\r\n     */\r\n    compare = (P: Polynom, sign?: string): boolean => {\r\n        if (sign === undefined) {\r\n            sign = '='\r\n        }\r\n\r\n        // Create clone version to reduce them without altering the original polynoms.\r\n        const cP1 = this.clone().reduce().reorder();\r\n        const cP2 = P.clone().reduce().reorder();\r\n\r\n        switch (sign) {\r\n            case '=':\r\n                // They must have the isSame length and the isSame degree\r\n                if (cP1.length !== cP2.length || cP1.degree() !== cP2.degree()) {\r\n                    return false;\r\n                }\r\n\r\n                // Check if the coefficients are the isSame.\r\n                for (const i in cP1.monoms) {\r\n                    if (!cP1.monoms[i].isEqual(cP2.monoms[i])) {\r\n                        return false;\r\n                    }\r\n                }\r\n                return true;\r\n            case 'same':\r\n                // They must have the isSame length and the isSame degree\r\n                if (cP1.length !== cP2.length || cP1.degree() !== cP2.degree()) {\r\n                    return false;\r\n                }\r\n\r\n                for (const i in cP1.monoms) {\r\n                    if (!cP1.monoms[i].isSameAs(cP2.monoms[i])) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n\r\n    isZero(): boolean {\r\n        return (this._monoms.length === 1 && this._monoms[0].coefficient.isZero()) || this._monoms.length === 0;\r\n    }\r\n\r\n    isOne(): boolean {\r\n        return this._monoms.length === 1 && this._monoms[0].coefficient.isOne();\r\n    }\r\n\r\n    isEqual = (P: Polynom): boolean => {\r\n        return this.compare(P, '=');\r\n    };\r\n\r\n    isSameAs = (P: Polynom): boolean => {\r\n        return this.compare(P, 'same');\r\n    };\r\n\r\n    isOpposedAt = (P: Polynom): boolean => {\r\n        return this.compare(P.clone().opposed(), '=');\r\n    };\r\n\r\n    isFactorized = (polynomString: string): boolean => {\r\n        let P = new Polynom(polynomString);\r\n\r\n        // Both polynom aren't the same (once developed and reduced => they cannot be equivalent)\r\n        if (!this.isEqual(P)) {\r\n            return false;\r\n        }\r\n\r\n        // Check if the provided (string) version is fully factorized.\r\n        // Run a regex on the string.\r\n        let polynomStringNormalized = polynomString.replaceAll('*', ''),\r\n            polynomStringReduced = '' + polynomStringNormalized,\r\n            factors: string[] = [];\r\n\r\n        for (let x of polynomStringNormalized.matchAll(/\\(([a-z0-9+\\-]+)\\)(\\^[0-9]*)?/g)) {\r\n            if (x[2] !== undefined) {\r\n                for (let i = 0; i < +x[2].substr(1); i++) {\r\n                    factors.push(x[1])\r\n                }\r\n            } else {\r\n                factors.push(x[1]);\r\n            }\r\n            polynomStringReduced = polynomStringReduced.replaceAll(x[0], '');\r\n        }\r\n        if (polynomStringReduced !== '') {\r\n            factors.push(polynomStringReduced);\r\n        }\r\n        let polyFactors = factors.map(x => new Polynom(x));\r\n\r\n        // Factorize the current polynom.\r\n        this.factorize();\r\n\r\n        // Compare the given factors with the generated factors\r\n        let sign = 1, maxNumberOfIteration = polyFactors.length * 2;\r\n        for (let f of this.factors) {\r\n            for (let i = 0; i < polyFactors.length; i++) {\r\n                if (f.isEqual(polyFactors[i])) {\r\n                    polyFactors.splice(i, 1);\r\n                    break;\r\n                } else if (f.isOpposedAt(polyFactors[i])) {\r\n                    polyFactors.splice(i, 1);\r\n                    sign = -sign;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // The polyfactors must be empty and the cumulative opposite factors must be 1.\r\n        return (polyFactors.length === 0 && sign === 1);\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Misc polynoms functions\r\n    // -------------------------------------\r\n    reduce = (): Polynom => {\r\n        for (let i = 0; i < this._monoms.length; i++) {\r\n            for (let j = i + 1; j < this._monoms.length; j++) {\r\n                if (this._monoms[i].isSameAs(this.monoms[j])) {\r\n                    this._monoms[i].add(this.monoms[j]);\r\n                    this._monoms.splice(j, 1);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Remove all null monoms\r\n        this._monoms = this._monoms.filter((m) => {\r\n            return m.coefficient.value !== 0\r\n        });\r\n\r\n        // Reduce all monoms coefficient.\r\n        for (const m of this._monoms) {\r\n            m.coefficient.reduce();\r\n        }\r\n\r\n        if (this.length === 0) {\r\n            return new Polynom().zero();\r\n        }\r\n        return this;\r\n    };\r\n\r\n    reorder = (letter: string = 'x'): Polynom => {\r\n        // TODO: Must handle multiple setLetter reorder system\r\n        this._monoms.sort(function (a, b) {\r\n            return b.degree(letter) - a.degree(letter)\r\n        });\r\n        return this.reduce();\r\n    };\r\n\r\n    degree = (letter?: string): number => {\r\n        let d: number = 0;\r\n        for (const m of this._monoms) {\r\n            d = Math.max(m.degree(letter), d);\r\n        }\r\n        return d;\r\n    };\r\n\r\n    letters = (): string[] => {\r\n        let L: string[] = [], S = new Set();\r\n\r\n        for (let m of this._monoms) {\r\n            S = new Set([...S, ...m.variables]);\r\n        }\r\n\r\n        // @ts-ignore\r\n        return [...S];\r\n    }\r\n\r\n    /**\r\n     * Replace a variable (letter) by a polynom.\r\n     * @param letter\r\n     * @param P\r\n     */\r\n    replaceBy = (letter: string, P: Polynom): Polynom => {\r\n        let pow: number;\r\n        const resultPolynom: Polynom = new Polynom().zero();\r\n\r\n        for (const m of this.monoms) {\r\n            if (m.literal[letter] === undefined || m.literal[letter] === 0) {\r\n                resultPolynom.add(m.clone());\r\n            } else {\r\n                // We have found a setLetter.\r\n                // Get the power and reset it.\r\n                pow = +m.literal[letter];\r\n                delete m.literal[letter];\r\n\r\n                resultPolynom.add(P.clone().pow(pow).multiply(m));\r\n            }\r\n        }\r\n\r\n        this._monoms = resultPolynom.reduce().reorder().monoms;\r\n        return this;\r\n    };\r\n\r\n    // Evaluate a polynom.\r\n    evaluate = (values: { [key: string]: Fraction }): Fraction => {\r\n        const r = new Fraction().zero();\r\n\r\n        this._monoms.forEach(monom => {\r\n            //console.log('Evaluate polynom: ', monom.display, values, monom.evaluate(values).display);\r\n            r.add(monom.evaluate(values));\r\n        });\r\n        return r;\r\n    };\r\n\r\n    derivative = (letter?: string): Polynom => {\r\n        let dP = new Polynom();\r\n\r\n        for (let m of this._monoms) {\r\n            dP.add(m.derivative(letter));\r\n        }\r\n\r\n        return dP;\r\n\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Polynoms factorization functions\r\n    // -------------------------------------\r\n    /**\r\n     * Factorize a polynom and store the best results in factors.\r\n     * @param maxValue Defines the greatest value to search to (default is 20).\r\n     */\r\n    factorize_OLD = (maxValue?: number): Polynom => {\r\n        // TODO: Must handle other letters than 'x'\r\n        this._factors = [];\r\n\r\n        // Duplicate the polynom\r\n        let P = this.clone(),\r\n            nbFactorsFound = 0;\r\n\r\n        // Determine if the polynom is \"negative\", eg has a max monom degree with a negative coefficient.\r\n        if (P.monomByDegree().coefficient.numerator < 0) {\r\n            this._factors.push(new Polynom('-1'));\r\n        }\r\n\r\n        // Determine if there is a 'common' monom\r\n        let M = P.commonMonom();\r\n        if (!M.isOne()) {\r\n            let commonPolynom = new Polynom()\r\n            commonPolynom.monoms = [M]\r\n            if (this._factors.length === 0) {\r\n                this._factors.push(commonPolynom);\r\n            } else {\r\n                this._factors = [];\r\n                this._factors.push(commonPolynom.opposed());\r\n            }\r\n            P = P.euclidian(commonPolynom).quotient;\r\n\r\n            nbFactorsFound = commonPolynom.degree();\r\n        }\r\n\r\n        // Main loop.\r\n        //\r\n        // Do it only if degree is equal or less than one.\r\n        if (P.degree() <= 1) {\r\n            this._factors.push(P.clone());\r\n        } else {\r\n            // Force test.\r\n            let Q = new Fraction(),\r\n                F,\r\n                degree = P.degree();\r\n\r\n            maxValue = maxValue === undefined ? 20 : maxValue;\r\n\r\n            // Test all polynom similar to ax+b\r\n            for (let a = 1; a <= maxValue; a++) {\r\n                // Skip a coefficient of 0\r\n                for (let b = -maxValue; b <= maxValue; b++) {\r\n\r\n                    Q.parse(-b, a);\r\n\r\n                    if (P.evaluate({x: Q})) {\r\n                        F = new Polynom(`${a}x+${b}`);\r\n                        while (P.evaluate({x: Q}).value === 0) {\r\n                            this._factors.push(F.clone());\r\n                            nbFactorsFound++;\r\n\r\n                            // Means it can be divided without reminders.\r\n                            P = P.euclidian(F).quotient;\r\n                        }\r\n                    }\r\n\r\n                    // Continue if the numbers of factors found equals the degree.\r\n                    if (nbFactorsFound > degree) {\r\n                        return this;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (P.degree() > 1) {\r\n                this._factors.push(P.clone());\r\n                return this;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    factorize = (letter?: string): Polynom[] => {\r\n        let factors: Polynom[] = [];\r\n\r\n        // Extract the common monom\r\n        let P = this.clone().reorder(),\r\n            M = P.commonMonom(),\r\n            tempPolynom: Polynom\r\n        // It has a common monom.\r\n        if (!M.isOne()) {\r\n            tempPolynom = new Polynom()\r\n            tempPolynom.monoms = [M]\r\n            factors = [tempPolynom.clone()]\r\n            P = P.euclidian(tempPolynom).quotient;\r\n        }\r\n\r\n        let securityLoop = P.degree() * 2\r\n        // securityLoop = 0\r\n        while (securityLoop >= 0) {\r\n            securityLoop--\r\n\r\n\r\n            if (P.monoms.length < 2) {\r\n                if (!P.isOne()) {\r\n                    factors.push(P.clone());\r\n                }\r\n                break;\r\n            } else {\r\n                // Get the first and last monom.\r\n                let m1 = P.monoms[0].dividers,\r\n                    m2 = P.monoms[P.monoms.length - 1].dividers\r\n\r\n                // console.log('CURRENT VALUE')\r\n                // console.log(P.tex)\r\n                // console.log('---------------------')\r\n                for (let m1d of m1) {\r\n                    for (let m2d of m2) {\r\n                        // if(m1d.degree()===m2d.degree()){continue}\r\n                        let dividerPolynom = new Polynom(),\r\n                            result\r\n                        dividerPolynom.monoms = [m1d.clone(), m2d.clone()]\r\n                        result = P.euclidian(dividerPolynom)\r\n\r\n                        // console.log(dividerPolynom.tex, '=>', result.reminder.tex, '|||||', result.quotient.tex)\r\n                        if (result.reminder.isZero()) {\r\n                            P = result.quotient.clone();\r\n                            factors.push(dividerPolynom)\r\n                            continue;\r\n                        }\r\n\r\n                        dividerPolynom.monoms = [m1d.clone(), m2d.clone().opposed()]\r\n                        result = P.euclidian(dividerPolynom)\r\n                        if (result.reminder.isZero()) {\r\n                            P = result.quotient.clone();\r\n                            factors.push(dividerPolynom)\r\n                        }\r\n                        // console.log(dividerPolynom.tex, '=>', result.reminder.tex)\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        this.factors = factors\r\n        return factors;\r\n        // let securityLoop = P.degree() * 2;\r\n        // while (P.degree(letter) >= 2 && securityLoop >= 0) {\r\n        //     // Avoid infinite looping\r\n        //     securityLoop--;\r\n        //\r\n        //     console.log(letter, P.degree(letter))\r\n        //     if (P.degree(letter) === 1) {\r\n        //         factors.push(P.clone())\r\n        //         // We are done !\r\n        //         return factors;\r\n        //\r\n        //     } else if (P.degree(letter) === 2) {\r\n        //         if(P.monoms.length===3) {\r\n        //             // Resolve using delta.\r\n        //             factors = [...factors, ...P._factorize2ndDegree(letter)];\r\n        //             // We are done !\r\n        //             return factors;\r\n        //         }else if(P.degree(letter)===2 && P.monoms.length===4) {\r\n        //             // Resolve using groups\r\n        //             factors = [...factors, ...P._factorizeByGroups()]\r\n        //         }\r\n        //\r\n        //     }else {\r\n        //         console.log('NOTHING TO DO: ', this.tex)\r\n        //     }\r\n        //\r\n        // }\r\n\r\n\r\n        return [];\r\n    }\r\n\r\n    private _factorize2ndDegree = (letter: string): Polynom[] => {\r\n        let P1: Polynom, P2: Polynom,\r\n            a, b, c, delta, x1, x2, factor;\r\n\r\n        // One variable only\r\n        if (this.numberOfVars === 1) {\r\n            a = this.monomByDegree(2, letter).coefficient;\r\n            b = this.monomByDegree(1, letter).coefficient;\r\n            c = this.monomByDegree(0, letter).coefficient;\r\n            delta = b.clone().pow(2).subtract(a.clone().multiply(c).multiply(4));\r\n\r\n            if (delta.isZero()) {\r\n                x1 = b.clone().opposed().divide(a.clone().multiply(2))\r\n                P1 = new Polynom(letter).subtract(x1.display).multiply(x1.denominator)\r\n                P2 = new Polynom(letter).subtract(x1.display).multiply(x1.denominator)\r\n                factor = a.divide(x1.denominator).divide(x1.denominator);\r\n\r\n                if (!factor.isOne()) {\r\n                    // TODO: Update new Polynom to accept anything...\r\n                    return [new Polynom(factor.display), P1, P2]\r\n                } else {\r\n                    return [P1, P2]\r\n                }\r\n            } else if (delta.isPositive() && delta.isSquare()) {\r\n                x1 = b.clone().opposed()\r\n                    .add(delta.clone().sqrt())\r\n                    .divide(a.clone().multiply(2))\r\n                x2 = b.clone().opposed()\r\n                    .subtract(delta.clone().sqrt())\r\n                    .divide(a.clone().multiply(2))\r\n\r\n                // (2x+5)(3x-2)\r\n                // 6x^2+11x-10\r\n                // a = 6, b = 11, c = -10\r\n                // delta = 121-4*6*(-10) = 361= 19^2\r\n                // x1 = (-11 + 19)  / 12 = 8/12 = 2/3\r\n                // x2 = (-11 - 19)  / 12 = -30/12 = -5/2\r\n                factor = a.divide(x1.denominator).divide(x2.denominator);\r\n                if (factor.isOne()) {\r\n                    return [\r\n                        new Polynom(letter).subtract(x1.display).multiply(x1.denominator),\r\n                        new Polynom(letter).subtract(x2.display).multiply(x2.denominator),\r\n                    ]\r\n                } else {\r\n                    return [\r\n                        new Polynom(factor.display),\r\n                        new Polynom(letter).subtract(x1.display).multiply(x1.denominator),\r\n                        new Polynom(letter).subtract(x2.display).multiply(x2.denominator),\r\n                    ]\r\n\r\n                }\r\n            } else {\r\n                // No solution possible - return the complete value.\r\n                return [this.clone()]\r\n            }\r\n        } else {\r\n            // If multiple variables, only handle perfect squares...\r\n            a = this.monomByDegree(2, letter);\r\n            b = this.monomByDegree(1, letter);\r\n            c = this.monomByDegree(0, letter);\r\n\r\n\r\n            if (a.isLitteralSquare() && c.isLitteralSquare()) {\r\n                // Check the middle item is same as...\r\n                if (b.clone().pow(2).isSameAs(a.clone().multiply(c))) {\r\n                    // Determine if the coefficient values matches.\r\n\r\n                    // Search 4 values (r, s, t, u) that matches:\r\n                    // (r X + s Y)(t X + u Y) = rt X^2 + (ru + st) XY + su Y^2\r\n\r\n                    let xPolynom = new Polynom('x', a.coefficient, b.coefficient, c.coefficient);\r\n                    let xFactors = xPolynom._factorize2ndDegree('x');\r\n\r\n                    let factors = [], xyzPolynom: Polynom;\r\n\r\n                    if (xFactors.length >= 2) {\r\n                        for (let p of xFactors) {\r\n                            if (p.degree() === 0) {\r\n                                factors.push(p.clone())\r\n                            } else {\r\n                                xyzPolynom = p.clone();\r\n                                xyzPolynom.monoms[0].literal = a.literalSqrt\r\n                                xyzPolynom.monoms[1].literal = c.literalSqrt\r\n                                factors.push(xyzPolynom.clone())\r\n                            }\r\n                        }\r\n                        return factors\r\n                    }\r\n                }\r\n            }\r\n\r\n            return [this.clone()]\r\n            //\r\n            // console.log(a.tex, b.tex, c.tex)\r\n            // if (a.isSquare() && c.isSquare()) {\r\n            //     console.log('A C squares')\r\n            //     if (a.clone().sqrt().multiply(c.clone().sqrt()).multiplyByNumber(2).isSameAs(b)) {\r\n            //         console.log('HERE')\r\n            //         if (a.coefficient.sign() === b.coefficient.sign()) {\r\n            //             return []\r\n            //         }else{\r\n            //             return []\r\n            //         }\r\n            //     }\r\n            // } else if(a.isLitteralSquare() && c.isLitteralSquare()) {\r\n            //     console.log('A C litteral SQUARES')\r\n            //     // Check that the middle element is the product of a and c.\r\n            //\r\n            //     if(b.clone().pow(2).isSameAs(a.clone().multiply(c))){\r\n            //         console.log('SAME')\r\n            //\r\n            //     }else{\r\n            //         console.log('NOT SAME')\r\n            //     }\r\n            //\r\n            //     return [this.clone()]\r\n            // } else {\r\n            //     console.log('NOT SQUARES AT ALL !!!!')\r\n            // }\r\n\r\n        }\r\n    }\r\n\r\n    private _factorizeByGroups = (): Polynom[] => {\r\n        // TODO: Factorize by groups.\r\n        return [];\r\n    }\r\n    // ------------------------------------------\r\n    // Polynoms helpers functions\r\n    // -------------------------------------\r\n    // TODO: get zeroes for more than first degree\r\n    getZeroes = (): (Fraction | boolean)[] => {\r\n        const Z: Fraction[] = [];\r\n\r\n        switch (this.degree()) {\r\n            case 0:\r\n                if (this._monoms[0].coefficient.value === 0) {\r\n                    return [true];\r\n                } else {\r\n                    return [false];\r\n                }\r\n            case 1:\r\n                // There is only one monoms,\r\n                if (this._monoms.length === 1) {\r\n                    return [new Fraction().zero()];\r\n                } else {\r\n                    const P = this.clone().reduce().reorder();\r\n                    return [P.monoms[1].coefficient.opposed().divide(P.monoms[0].coefficient)];\r\n                }\r\n            // TODO: Determine the zeros of an equation of second degree.\r\n            //case 2:\r\n            default:\r\n                if (this._monoms.length === 1) {\r\n                    return [new Fraction().zero()];\r\n                }\r\n\r\n                // Make sure the polynom is factorized.\r\n                if (this._factors.length === 0) {\r\n                    this.factorize()\r\n                }\r\n\r\n                let zeroes = [], zeroesAsTex = [];\r\n                for (let P of this._factors) {\r\n                    if (P.degree() > 2) {\r\n                        // TODO: Handle other polynom.\r\n\r\n                    } else if (P.degree() === 2) {\r\n                        let A = P.monomByDegree(2).coefficient,\r\n                            B = P.monomByDegree(1).coefficient,\r\n                            C = P.monomByDegree(0).coefficient,\r\n                            D = B.clone().pow(2).subtract(A.clone().multiply(C).multiply(4));\r\n\r\n                        if (D.value > 0) {\r\n                            /*console.log('Two zeroes for ', P.tex); */\r\n                            let x1 = (-(B.value) + Math.sqrt(D.value)) / (2 * A.value),\r\n                                x2 = (-(B.value) - Math.sqrt(D.value)) / (2 * A.value);\r\n\r\n                            zeroes.push(new Fraction(x1.toFixed(3)).reduce());\r\n                            zeroes.push(new Fraction(x2.toFixed(3)).reduce());\r\n                        } else if (D.value === 0) {\r\n                            /*console.log('One zero for ', P.tex); */\r\n\r\n                        } else {\r\n                            console.log('No zero for ', P.tex);\r\n                            return [false]\r\n                        }\r\n                    } else {\r\n                        for (let z of P.getZeroes()) {\r\n                            // Check if the zero is already in the list.\r\n                            if (z === false || z === true) {\r\n                                continue;\r\n                            }\r\n                            if (zeroesAsTex.indexOf(z.frac) === -1) {\r\n                                zeroes.push(z);\r\n                                zeroesAsTex.push(z.frac);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return zeroes;\r\n        }\r\n        return Z;\r\n    };\r\n\r\n\r\n    // TODO: analyse the next functions to determine if they are useful or not...\r\n    monomByDegree = (degree?: number, letter?: string): Monom => {\r\n        if (degree === undefined) {\r\n            // return the highest degree monom.\r\n            return this.monomByDegree(this.degree(letter), letter);\r\n        }\r\n\r\n        // Reduce the polynom.\r\n        const M = this.clone().reduce();\r\n        for (const m of M._monoms) {\r\n            if (m.degree(letter) === degree) {\r\n                return m.clone();\r\n            }\r\n        }\r\n\r\n        // Nothing was found - return the null monom.\r\n        return new Monom().zero();\r\n    };\r\n\r\n    monomsByDegree = (degree?: number, letter?: string): Monom[] => {\r\n        if (degree === undefined) {\r\n            // return the highest degree monom.\r\n            return this.monomsByDegree(this.degree(letter));\r\n        }\r\n\r\n        // Reduce the polynom.\r\n        let Ms: Monom[] = [];\r\n\r\n        const M = this.clone().reduce();\r\n        for (const m of M._monoms) {\r\n            if (m.degree(letter) === degree) {\r\n                Ms.push(m.clone())\r\n            }\r\n        }\r\n\r\n        return Ms\r\n        // Nothing was found - return\r\n    }\r\n\r\n    // Used in LinearSystem.tex\r\n    monomByLetter = (letter: string): Monom => {\r\n        const M = this.clone().reduce();\r\n        for (const m of M._monoms) {\r\n            if (m.hasLetter(letter)) {\r\n                return m.clone();\r\n            }\r\n        }\r\n\r\n        return new Monom().zero();\r\n    };\r\n\r\n    // Next functions are used for for commonMonom, which is used in the factorize method.\r\n    getDenominators = (): number[] => {\r\n        const denominators: number[] = [];\r\n        for (const m of this._monoms) {\r\n            denominators.push(m.coefficient.denominator);\r\n        }\r\n        return denominators;\r\n    };\r\n\r\n    getNumerators = (): number[] => {\r\n        const numerators: number[] = [];\r\n        for (const m of this._monoms) {\r\n            numerators.push(m.coefficient.numerator);\r\n        }\r\n        return numerators;\r\n    };\r\n\r\n    lcmDenominator = (): number => {\r\n        return Numeric.lcm(...this.getDenominators());\r\n    };\r\n\r\n    gcdDenominator = (): number => {\r\n        return Numeric.gcd(...this.getDenominators());\r\n    };\r\n\r\n    lcmNumerator = (): number => {\r\n        return Numeric.lcm(...this.getNumerators());\r\n    };\r\n\r\n    gcdNumerator = (): number => {\r\n        return Numeric.gcd(...this.getNumerators());\r\n    };\r\n\r\n    commonMonom = (): Monom => {\r\n        let M = new Monom().one(), numerator: number, denominator: number, degree = this.degree();\r\n\r\n        numerator = this.gcdNumerator();\r\n        denominator = this.gcdDenominator();\r\n\r\n        M.coefficient = new Fraction(numerator, denominator);\r\n        for (let L of this.variables) {\r\n            // Initialize the setLetter with the max degree\r\n            M.setLetter(L, degree);\r\n            for (let m of this._monoms) {\r\n                M.setLetter(L, Math.min(m.degree(L), M.degree(L)));\r\n                if (M.degree(L) === 0) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return M;\r\n    }\r\n\r\n\r\n    // TODO: The rest of the functions are not used or unnecessary ?\r\n    /**\r\n     * This will generate a not reduced tex string of the polynom.\r\n     * @param complexity : Number of iteration to increase the complexity.\r\n     */\r\n    makeItComplicate = (complexity: number = 1): Polynom => {\r\n        this._texString = '';\r\n\r\n        // The polynom must be at least of the first degree.\r\n        if (this.degree() < 1) {\r\n            return this;\r\n        }\r\n\r\n        const mDegree = Numeric.randomInt(0, this.degree() - 1);\r\n        const A = new Polynom().rndSimple(mDegree, false, complexity > 1, 'x', false, complexity > 1 ? -1 : 1);\r\n        const B = new Polynom().rndSimple(1, false, complexity > 1);\r\n        const C = this.clone().subtract(A.clone().multiply(B));\r\n\r\n        // Try to factorize a little bit the C polynom.\r\n        C.factorizePartial(true);\r\n        this._texString = `${A.genDisplay('tex', false, true)} \\\\cdot ${B.genDisplay('tex', false, true)} ${C.texString} `;\r\n\r\n        return this;\r\n    };\r\n    factorizePartial = (forceSign?: boolean): Polynom => {\r\n        this._texString = '';\r\n        // Try to find two monoms with a common coefficient.\r\n        if (this.length <= 1) {\r\n            return this;\r\n        }\r\n\r\n        let mMain: Monom,\r\n            mCheck: Monom,\r\n            mFactor: Monom,\r\n            pFactor: Polynom,\r\n            // pRemain: Polynom,\r\n            g: number, sign: string;\r\n\r\n        for (let i = 0; i < this.length; i++) {\r\n            mMain = this._monoms[i].clone();\r\n            // We factorize only if the main coefficient isn't a fraction\r\n            // if(mMain.coefficient.denominator!==1){continue;}\r\n            for (let j = i + 1; j < this.length; j++) {\r\n                mCheck = this._monoms[j].clone();\r\n                // if(mCheck.coefficient.denominator!==1){continue;}\r\n\r\n                g = Numeric.gcd(mMain.coefficient.numerator, mCheck.coefficient.numerator);\r\n                if (g !== 1) {\r\n                    // mFactor = mMain.clone().divide(mCheck); // This gets the literal part.\r\n                    // mFactor.coefficient = new Fraction(g); // Set the coefficient to the gcd.\r\n                    mFactor = Monom.lcm(mMain, mCheck);\r\n                    sign = mMain.coefficient.sign() === 1 ? '+' : '-';\r\n                    this._texString = `${forceSign === true ? sign : (sign === '+' ? '' : sign)}${mFactor.tex}`;\r\n\r\n                    pFactor = new Polynom().add(mMain.divide(mFactor)).add(mCheck.divide(mFactor));\r\n                    this._texString += pFactor.genDisplay('tex', false, true);\r\n\r\n                    this._texString += this.clone().subtract(pFactor.clone().multiply(mFactor)).genDisplay('tex', true, false);\r\n                    return this;\r\n                }\r\n            }\r\n        }\r\n\r\n        this._texString = this.genDisplay('tex', forceSign);\r\n\r\n        return this;\r\n    };\r\n    /**\r\n     * reduce the coefficient value as if the polynom was equal to zero.\r\n     */\r\n    minify = (): Polynom => {\r\n        // First multiply by the common denominator.\r\n        this.multiply(this.lcmDenominator()).divide(this.gcdNumerator()).reduce();\r\n        return this.reduce();\r\n    };\r\n    /**\r\n     * Determine if the current polynom is divisible by P\r\n     * TODO: should work with any polynom, not only first degree polynoms and the setLetter should disappear\r\n     * @param P\r\n     * @param letter - default setLetter\r\n     */\r\n    canDivide = (P: Polynom, letter: string = 'x'): boolean => {\r\n        const d = P.degree();\r\n\r\n        const evalValue: { [key: string]: Fraction } = {};\r\n        // A zero degree polynom can always divide, except if it's the zero polynom.\r\n        if (d === 0) {\r\n            return !P.isZero;\r\n        }\r\n\r\n        // The polynom is of degree one.\r\n        if (d === 1) {\r\n            const z = P.getZeroes();\r\n            // The zero is an undefined zero.\r\n            if (z[0] === true || z[0] === false) {\r\n                return false;\r\n            }\r\n\r\n            evalValue[letter] = z[0];\r\n            return this.evaluate(evalValue).value === 0;\r\n        }\r\n\r\n        // The polynom is of degree 2 or more...\r\n        if (d > 1) {\r\n            console.log('Currently, only first degree polynom are supported');\r\n            return false;\r\n        }\r\n\r\n        return false;\r\n    };\r\n\r\n\r\n}\r\n","/**\r\n * Rational polynom module contains everything necessary to handle rational polynoms.\r\n * @module Polynom\r\n */\r\n\r\nimport {Polynom} from \"./polynom\";\r\n\r\n/**\r\n * Rational class can handle rational polynoms\r\n */\r\nexport class Rational {\r\n    private _rawString: string;\r\n    private _numerator: Polynom;\r\n    private _denominator: Polynom;\r\n\r\n    /**\r\n     *\r\n     * @param numerator\r\n     * @param denominator\r\n     */\r\n    constructor(numerator?: Polynom, denominator?: Polynom) {\r\n        this._numerator = numerator?numerator.clone():new Polynom();\r\n        this._denominator = denominator?denominator.clone():new Polynom();\r\n    }\r\n\r\n    clone = (): Rational => {\r\n        this._numerator = this._numerator.clone()\r\n        this._denominator = this._denominator.clone()\r\n\r\n        return this;\r\n    }\r\n\r\n    get tex(): string {\r\n        return `\\\\dfrac{ ${this._numerator.tex} }{ ${this._denominator.tex} }`;\r\n    }\r\n\r\n    get texFactors(): string {\r\n        this._numerator.factorize()\r\n        this._denominator.factorize()\r\n\r\n        return `\\\\dfrac{ ${this._numerator.texFactors} }{ ${this._denominator.texFactors} }`\r\n    }\r\n\r\n    get numerator(): Polynom {\r\n        return this._numerator\r\n    }\r\n    get denominator(): Polynom {\r\n        return this._denominator\r\n    }\r\n\r\n    domain = (): string => {\r\n        let zeroes = this._denominator.getZeroes();\r\n        if( zeroes.length===0 || zeroes[0]===false){\r\n            return '\\\\mathbb{R}'\r\n        }else if(zeroes[0]===true){\r\n            return '\\\\varnothing'\r\n        }else{\r\n            return '\\\\mathbb{R}\\\\setminus\\\\left{'+\r\n                zeroes.map(x=> {\r\n                    return (typeof x === 'boolean')?'':x.frac\r\n                    })\r\n                    .join(';')+'\\\\right}'\r\n        }\r\n    }\r\n\r\n    amplify = (P: Polynom): Rational => {\r\n        this._numerator.multiply(P);\r\n        this._denominator.multiply(P);\r\n\r\n        return this;\r\n    }\r\n\r\n    simplify = (P: Polynom): Rational => {\r\n        let NumeratorEuclidien = this._numerator.euclidian(P);\r\n        if(!NumeratorEuclidien.reminder.isZero()){return this;}\r\n\r\n        let DenominatorEuclidien = this._denominator.euclidian(P);\r\n        if(!DenominatorEuclidien.reminder.isZero()){return this;}\r\n\r\n        this._numerator = NumeratorEuclidien.quotient;\r\n        this._denominator = DenominatorEuclidien.quotient;\r\n        return this;\r\n    }\r\n\r\n    reduce = (): Rational => {\r\n        console.log(this._numerator.tex)\r\n        this._numerator.factorize();\r\n        console.log(this._numerator.factors.map(x => x.tex))\r\n        for(let f of this._numerator.factors){\r\n            this.simplify(f);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    opposed = (): Rational => {\r\n        this._numerator.opposed();\r\n        return this;\r\n    }\r\n    add = (R: Rational): Rational => {\r\n        // 1. Make sure both rational are at the same denominator\r\n        // 2. Add the numerators.\r\n        // 3. Simplify\r\n\r\n        // Store the adding denominator\r\n        let denominator = this._denominator.clone()\r\n\r\n        // Amplif the main rational polynom by the adding denominator\r\n        this.amplify(R._denominator)\r\n\r\n        // Add to the numerator the adding value...\r\n        this._numerator.add(R._numerator.clone().multiply(denominator));\r\n\r\n        return this;\r\n    }\r\n\r\n    subtract = (R: Rational): Rational => {\r\n        return this.add(R.clone().opposed())\r\n    }\r\n}","import {Numeric} from \"../numeric\";\r\n\r\nexport class Fraction {\r\n    private _numerator: number;\r\n    private _denominator: number;\r\n\r\n    constructor(value?: unknown, denominatorOrPeriodic?: number) {\r\n        this._numerator = 1;\r\n        this._denominator = 1;\r\n\r\n        return this.parse(value, denominatorOrPeriodic);\r\n    }\r\n\r\n    get isFraction() {\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n\r\n    get numerator(): number {\r\n        return this._numerator;\r\n    }\r\n\r\n    set numerator(value: number) {\r\n        this._numerator = value;\r\n    }\r\n\r\n    get denominator(): number {\r\n        return this._denominator;\r\n    }\r\n\r\n    set denominator(value: number) {\r\n        this._denominator = value;\r\n    }\r\n\r\n    get value(): number {\r\n        return this._numerator / this._denominator;\r\n    }\r\n\r\n    // Display getter\r\n    get tex(): string {\r\n        if (this._denominator === 1) {\r\n            return `${this._numerator}`;\r\n        } else if (this._numerator < 0) {\r\n            return `-\\\\frac{ ${-this._numerator} }{ ${this._denominator} }`;\r\n        } else {\r\n            return `\\\\frac{ ${this._numerator} }{ ${this._denominator} }`;\r\n        }\r\n    }\r\n\r\n    get display(): string {\r\n        if (this._denominator === 1) {\r\n            return `${this._numerator}`;\r\n        } else {\r\n            return `${this._numerator}/${this._denominator}`;\r\n        }\r\n    }\r\n\r\n    // Helper function to display fractions\r\n    get frac(): string {\r\n        return this.tex;\r\n    }\r\n\r\n    get dfrac(): string {\r\n        return this.tex.replace('\\\\frac', '\\\\dfrac');\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    /**\r\n     * Parse the value to get the numerator and denominator\r\n     * @param value : number or string to parse to get the fraction\r\n     * @param denominatorOrPeriodic (optional|number) : length of the periodic part: 2.333333 => 1 or denominator value\r\n     */\r\n    parse = (value: unknown, denominatorOrPeriodic?: number): Fraction => {\r\n        let S: string[];\r\n\r\n        // A null value means a zero fraction.\r\n        if (value === null) {\r\n            this._numerator = 0;\r\n            this._denominator = 1;\r\n            return this;\r\n        }\r\n\r\n        switch (typeof value) {\r\n            case \"string\":\r\n                // Split the sting value in two parts: Numerator/Denominator\r\n                S = value.split('/');\r\n\r\n                // Security checks\r\n                if (S.length > 2) throw \"Two many divide signs\";\r\n                if (S.map(x => x === '' || isNaN(Number(x))).includes(true)) throw \"Not a number\"\r\n\r\n                if (S.length === 1) {\r\n                    // No divide sign\r\n                    return this.parse(+S[0]);\r\n                } else if (S.length === 2) {\r\n                    // One divide signe\r\n                    // We check if the denominator is zero\r\n                    if (S[1] === '0') {\r\n                        this._numerator = NaN;\r\n                        this._denominator = 1;\r\n                    } else {\r\n                        this._numerator = +S[0];\r\n                        this._denominator = +S[1];\r\n                    }\r\n                } else {\r\n                    // More than one divide sign ?\r\n                    this._numerator = NaN;\r\n                    this._denominator = 1;\r\n                }\r\n                break;\r\n            case \"number\":\r\n                if (Number.isSafeInteger(value)) {\r\n                    // The given value is an integer\r\n                    this._numerator = +value;\r\n\r\n                    if (denominatorOrPeriodic === undefined || !Number.isSafeInteger(denominatorOrPeriodic)) {\r\n                        this._denominator = 1;\r\n                    } else {\r\n                        this._denominator = +denominatorOrPeriodic;\r\n                    }\r\n                } else {\r\n                    // The given value is a float number\r\n\r\n                    // Get the number of decimals after the float sign\r\n                    let p: number = (value.toString()).split('.')[1].length;\r\n\r\n                    // Transform the float number in two integer\r\n                    if (denominatorOrPeriodic === undefined) {\r\n                        this._numerator = value * Math.pow(10, p);\r\n                        this._denominator = Math.pow(10, p);\r\n                    } else if (Number.isSafeInteger(denominatorOrPeriodic)) {\r\n                        this._numerator = value * Math.pow(10, p) - Math.floor(value * Math.pow(10, p - denominatorOrPeriodic));\r\n                        this.denominator = Math.pow(10, p) - Math.pow(10, p - denominatorOrPeriodic)\r\n                    }\r\n                }\r\n                break;\r\n            case \"object\":\r\n                if (value instanceof Fraction) {\r\n                    this._numerator = +value.numerator;\r\n                    this._denominator = +value.denominator;\r\n                }\r\n                break;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Clone the current fraction\r\n     */\r\n    clone = (): Fraction => {\r\n        let F = new Fraction();\r\n        F.numerator = +this._numerator;\r\n        F.denominator = +this._denominator;\r\n        return F;\r\n    };\r\n\r\n    /**\r\n     * Define the fraction as zero\r\n     */\r\n    zero = (): Fraction => {\r\n        this._numerator = 0;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Define the fraction as neutral (one)\r\n     */\r\n    one = (): Fraction => {\r\n        this._numerator = 1;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Define the fraction as (positive) infinite\r\n     */\r\n    infinite = (): Fraction => {\r\n        this._numerator = Infinity;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Define the fraction as not a number (means an error)\r\n     */\r\n    invalid = (): Fraction => {\r\n        this._numerator = NaN;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    /**\r\n     * Set the fraction to it's opposite\r\n     */\r\n    opposed = (): Fraction => {\r\n        this._numerator = -this._numerator;\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Add another fraction\r\n     * @param F Fraction\r\n     */\r\n    add = (F: unknown): Fraction => {\r\n        let Q = new Fraction(F)\r\n\r\n        let N: number = this._numerator,\r\n            D: number = this._denominator;\r\n\r\n        this._numerator = N * Q.denominator + Q.numerator * D;\r\n        this._denominator = D * Q.denominator;\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    /**\r\n     * Subtract another fraction\r\n     * @param F Fraction\r\n     */\r\n    subtract = (F: unknown): Fraction => {\r\n        return this.add(new Fraction(F).opposed());\r\n    };\r\n\r\n    /**\r\n     * Multiply by another Fraction or number\r\n     * @param F\r\n     */\r\n    multiply = (F: unknown): Fraction => {\r\n        // Parse the value.\r\n        // If it's a fraction, return a clone of it\r\n        // If it's an integer, return the fraction F/1\r\n        let Q = new Fraction(F);\r\n\r\n        this._numerator = this._numerator * Q.numerator;\r\n        this._denominator = this._denominator * Q.denominator;\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    /**\r\n     * Divide by a fraction\r\n     * @param F Fraction\r\n     */\r\n    divide = (F: unknown): Fraction => {\r\n        let Q = new Fraction(F);\r\n\r\n        // The divider is null\r\n        if (Q.isZero()) {\r\n            return new Fraction().infinite()\r\n        }\r\n\r\n        // Dividing = multiply by invert\r\n        return this.multiply(Q.invert())\r\n    };\r\n\r\n    /**\r\n     * Invert the fraction\r\n     */\r\n    invert = (): Fraction => {\r\n        if (this.isZero()) {\r\n            return this.infinite()\r\n        }\r\n\r\n        let n = +this._numerator, d = +this._denominator;\r\n        this._numerator = d;\r\n        this._denominator = n;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Pow the fraction...\r\n     * @param p integer\r\n     */\r\n    pow = (p: number): Fraction => {\r\n        // The power number must be an integer.\r\n        if (!Number.isSafeInteger(p)) {\r\n            return this.invalid();\r\n        }\r\n\r\n        // Trivial pow\r\n        if (p === 0) {\r\n            return this.one()\r\n        }\r\n        if (p === 1) {\r\n            return this\r\n        }\r\n        if (p === -1) {\r\n            return this.invert()\r\n        }\r\n\r\n        // Reduce the fraction before pow\r\n        this.reduce();\r\n\r\n        // The power is negative -> invert the fraction.\r\n        if (p < 0) {\r\n            this.invert()\r\n        }\r\n\r\n        // Pow each number\r\n        this._numerator = this._numerator ** Math.abs(p);\r\n        this._denominator = this._denominator ** Math.abs(p);\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Get the root value of a fraction\r\n     * @param p integer\r\n     */\r\n    root = (p: number): Fraction => {\r\n        // TODO: nth - root of a fraction => this will return another type of coefficient.\r\n\r\n        // Trivial roots\r\n        if (p === 0) {\r\n            return this.invalid();\r\n        }\r\n        if (p === 1) {\r\n            return this;\r\n        }\r\n        if (p === -1) {\r\n            return this.invert();\r\n        }\r\n\r\n        /* If negative, invert the fraction*/\r\n        if (p < 0) {\r\n            this.invert()\r\n        }\r\n\r\n        // TODO: root: Actually, it gives floating number\r\n        this._numerator = Math.pow(this._numerator, Math.abs(1 / p));\r\n        this._denominator = Math.pow(this._denominator, Math.abs(1 / p));\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Return the square root of the fraction\r\n     */\r\n    sqrt = (): Fraction => {\r\n        return this.root(2);\r\n    }\r\n\r\n    /**\r\n     * Return the absolute value of the fraction\r\n     */\r\n    abs = (): Fraction => {\r\n        this._numerator = Math.abs(this._numerator);\r\n        this._denominator = Math.abs(this._denominator);\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations specific to fractions\r\n    // ------------------------------------------\r\n    /**\r\n     * Reduce the fraction\r\n     */\r\n    reduce = (): Fraction => {\r\n        let g = Numeric.gcd(this._numerator, this._denominator);\r\n        this._numerator = this._numerator / g;\r\n        this._denominator = this._denominator / g;\r\n\r\n        if (this._denominator < 0) {\r\n            this._denominator = -this._denominator;\r\n            this._numerator = -this._numerator;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Amplify the fraction by a value\r\n     * @param k integer\r\n     */\r\n    amplify = (k: number): Fraction => {\r\n        if (Number.isSafeInteger(k)) {\r\n            this._numerator *= k;\r\n            this._denominator *= k;\r\n        }\r\n        return this;\r\n    };\r\n\r\n\r\n    // ------------------------------------------\r\n    // Compare functions\r\n    // ------------------------------------------\r\n    /**\r\n     * Compare the current coefficient with another coefficient\r\n     * @param F (Coefficient) The coefficient to compare\r\n     * @param sign (string| default is =): authorized values: =, <, <=, >, >= with some variations.\r\n     */\r\n    compare = (F: Fraction, sign?: string): boolean => {\r\n        if (sign === undefined) {\r\n            sign = '=';\r\n        }\r\n\r\n\r\n        switch (sign) {\r\n            case '>':\r\n                return this.value > F.value;\r\n            case \">=\" || \"=>\" || \"geq\":\r\n                return this.value >= F.value;\r\n            case \"<\":\r\n                return this.value < F.value;\r\n            case \"<=\" || \"=>\" || \"leq\":\r\n                return this.value <= F.value;\r\n            case \"=\":\r\n                // let F2: Fraction = F.clone().reduce(),\r\n                //     F1: Fraction = this.clone().reduce();\r\n                // return (F1.numerator === F2.numerator && F1.denominator === F2.denominator);\r\n                return this.value === F.value;\r\n            case \"<>\":\r\n                return this.value !== F.value;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /* Compare shortcuts */\r\n\r\n    /**\r\n     * Compare less than fraction\r\n     * @param than\r\n     */\r\n    lesser = (than: Fraction): Boolean => {\r\n        return this.compare(than, '<');\r\n    };\r\n    /**\r\n     * Compare less or equal than fraction\r\n     * @param than\r\n     */\r\n    leq = (than: Fraction): Boolean => {\r\n        return this.compare(than, '<=');\r\n    };\r\n    /**\r\n     * Compare greater than fraction\r\n     * @param than\r\n     */\r\n    greater = (than: Fraction): Boolean => {\r\n        return this.compare(than, '>');\r\n    };\r\n    /**\r\n     * Compare greater or equal than fraction\r\n     * @param than\r\n     */\r\n    geq = (than: Fraction): Boolean => {\r\n        return this.compare(than, '>=');\r\n    };\r\n    /**\r\n     * Compare is equal to fraction\r\n     * @param than\r\n     */\r\n    isEqual = (than: Fraction): boolean => {\r\n        return this.compare(than, '=');\r\n    }\r\n    /**\r\n     * Compare: is different to fraction\r\n     * @param than\r\n     */\r\n    isDifferent = (than: Fraction): boolean => {\r\n        return this.compare(than, '<>');\r\n    }\r\n    /**\r\n     * Compare: is opposed to fraction\r\n     * @param p\r\n     */\r\n    isOpposed = (p: Fraction): boolean => {\r\n        return this.isEqual(p.clone().opposed());\r\n    }\r\n    /**\r\n     * Compare: is invert to fraction\r\n     * @param p\r\n     */\r\n    isInverted = (p: Fraction): boolean => {\r\n        return this.isEqual(new Fraction().one().divide(p.clone()));\r\n    }\r\n    /**\r\n     * Compare: is equal to zero\r\n     */\r\n    isZero = (): boolean => {\r\n        return this._numerator === 0;\r\n    }\r\n    /**\r\n     * Compare: is equal to one\r\n     */\r\n    isOne = (): boolean => {\r\n        return this._numerator === 1 && this._denominator === 1;\r\n    }\r\n    /**\r\n     * Compare: is positive\r\n     */\r\n    isPositive = (): boolean => {\r\n        return this.sign() === 1;\r\n    }\r\n    /**\r\n     * Compare: is negative\r\n     */\r\n    isNegative = (): boolean => {\r\n        return this.sign() === -1;\r\n    }\r\n    /**\r\n     * Compare: is not a number (NaN)\r\n     */\r\n    isNaN = (): boolean => {\r\n        return isNaN(this._numerator);\r\n    }\r\n    /**\r\n     * Compare is inifinite\r\n     */\r\n    isInfinity = (): boolean => {\r\n        return this._numerator === Infinity;\r\n    }\r\n    /**\r\n     * Compare is finite ?\r\n     */\r\n    isFinite = (): boolean => {\r\n        return !this.isInfinity();\r\n    }\r\n    /**\r\n     * Compare: are the numerator and denominator perfect square ?\r\n     */\r\n    isSquare = (): boolean => {\r\n        return Math.sqrt(this._numerator) % 1 === 0 && Math.sqrt(this._denominator) % 1 === 0\r\n    }\r\n    /**\r\n     * Get the sign of the fraction\r\n     */\r\n    sign = (): number => {\r\n        return (this._numerator * this._denominator >= 0) ? 1 : -1;\r\n    };\r\n}","export class Nthroot {\r\n    private _radical: number;\r\n    private _nth: number;\r\n    private _coefficient: number;\r\n    private _isValid:boolean;\r\n\r\n    constructor() {\r\n        this._radical = 1;\r\n        this._coefficient = 1;\r\n        this._nth = 2;\r\n        this._isValid = true;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get radical(): number {\r\n        return this._radical;\r\n    }\r\n\r\n    set radical(value: number) {\r\n        this._radical = value;\r\n    }\r\n\r\n    get nth(): number {\r\n        return this._nth;\r\n    }\r\n\r\n    set nth(value: number) {\r\n        if (Number.isSafeInteger(value) && value >= 2) {\r\n            this._nth = value;\r\n        } else {\r\n            // Error setting the nth root.\r\n            console.log('Error setting the nth root');\r\n            this._nth = 2;\r\n        }\r\n    }\r\n\r\n    get coefficient(): number {\r\n        return this._coefficient;\r\n    }\r\n\r\n    set coefficient(value: number) {\r\n        this._coefficient = value;\r\n    }\r\n\r\n    get tex(): string {\r\n        let C: string;\r\n\r\n        if (this._coefficient === 1) {\r\n            C = '';\r\n        } else if (this._coefficient === -1) {\r\n            C = '-';\r\n        } else {\r\n            C = this._coefficient.toString();\r\n        }\r\n\r\n        if (this._radical === 1) {\r\n            return `${this._coefficient}`;\r\n        } else {\r\n            if (this._nth === 2) {\r\n                return `${C}\\\\sqrt{${this._radical}}`\r\n            } else {\r\n                return `${C}\\\\sqrt[${this._nth}]{${this._radical}}`\r\n            }\r\n        }\r\n    }\r\n\r\n    get value(): number {\r\n        return this._coefficient * Math.pow(this._radical, 1 / this._nth);\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    parse = (radical: number, nthroot?: number, coefficient?: number): Nthroot => {\r\n        this._coefficient = (coefficient === undefined) ? 1 : coefficient;\r\n        this._nth = (nthroot === undefined) ? 2 : nthroot;\r\n        this._radical = (radical === undefined) ? 1 : radical;\r\n\r\n        if(this._nth%2===0 && this._radical<0){\r\n            this._isValid = false;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    reduce = (): Nthroot => {\r\n        // Max value to test.\r\n        let V = Math.floor(Math.pow(this._radical, 1 / this._nth));\r\n        while (V > 1) {\r\n            if (this._radical % Math.pow(V, this._nth) === 0) {\r\n                // It's dividable by V^n\r\n                this._coefficient *= V;\r\n                this._radical = this._radical / Math.pow(V, this._nth);\r\n\r\n                // Redifine the new testing value (this is optimization)\r\n                V = Math.floor(Math.pow(this._radical, 1 / this._nth));\r\n                continue;\r\n            }\r\n            V--;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    multiply = (N: Nthroot): Nthroot => {\r\n        this._radical *= N.radical;\r\n        return this.reduce();\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Help functions\r\n    // ------------------------------------------\r\n    hasRadical = ():boolean => {\r\n        return !(this._radical===1 || this._radical===0 || this._isValid===false)\r\n    };\r\n}","/**\r\n * This class works for 2d line in a plane.\r\n */\r\n\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Vector} from \"./vector\";\r\nimport {Point} from \"./point\";\r\nimport {Polynom} from \"../algebra/polynom\";\r\nimport {Numeric} from \"../numeric\";\r\nimport {Equation} from \"../algebra/equation\";\r\n\r\nexport class Line {\r\n    // A line is defined as the canonical form\r\n    // ax + by + c = 0\r\n    private _a: Fraction;\r\n    private _b: Fraction;\r\n    private _c: Fraction;\r\n    private _OA: Point;\r\n    private _d: Vector;\r\n    private _n: Vector;\r\n    private _exists: boolean\r\n\r\n    constructor(...values: any) {\r\n\r\n        this._exists = false;\r\n\r\n        if (values !== undefined) {\r\n            this.parse(...values);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    get isLine():boolean {return true;}\r\n    get exists(): boolean {return this._exists; }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get equation(): Equation {\r\n        return new Equation(new Polynom().parse('xy', this._a, this._b, this._c), new Polynom('0')).simplify();\r\n    }\r\n    get tex(): { canonical: string, mxh: string, parametric: string } {\r\n        // canonical    =>  ax + by + c = 0\r\n        // mxh          =>  y = -a/b x - c/b\r\n        // parametric   =>  (xy) = OA + k*d\r\n\r\n        let canonical = this.equation;\r\n        // Make sur the first item is positive.\r\n        if(this._a.isNegative()){\r\n            canonical.multiply(-1);\r\n        }\r\n\r\n        return {\r\n            canonical: canonical.tex,\r\n            mxh: this.slope.isInfinity() ? 'x=' + this.OA.x.tex : 'y=' + new Polynom().parse('x', this.slope, this.height).tex,\r\n            parametric: `${Point.pmatrix('x', 'y')} = ${Point.pmatrix(this._OA.x, this._OA.y)} + k\\\\cdot ${Point.pmatrix(this._d.x, this._d.y)}`\r\n        }\r\n    }\r\n\r\n    get a(): Fraction {\r\n        return this._a;\r\n    }\r\n\r\n    set a(value: Fraction) {\r\n        this._a = value;\r\n    }\r\n\r\n    get b(): Fraction {\r\n        return this._b;\r\n    }\r\n\r\n    set b(value: Fraction) {\r\n        this._b = value;\r\n    }\r\n\r\n    get c(): Fraction {\r\n        return this._c;\r\n    }\r\n\r\n    set c(value: Fraction) {\r\n        this._c = value;\r\n    }\r\n\r\n    get OA(): Point {\r\n        return this._OA;\r\n    }\r\n\r\n    set OA(value: Point) {\r\n        this._OA = value;\r\n    }\r\n\r\n    get d(): Vector {\r\n        return this._d;\r\n    }\r\n\r\n    get n(): Vector {\r\n        return this._n;\r\n    }\r\n\r\n    get normal(): Vector {\r\n        return new Vector(this._a, this._b);\r\n    }\r\n\r\n    set d(value: Vector) {\r\n        this._d = value;\r\n    }\r\n\r\n    get slope(): Fraction {\r\n        return this._a.clone().opposed().divide(this._b);\r\n    }\r\n\r\n    get height(): Fraction {\r\n        return this._c.clone().opposed().divide(this._b);\r\n    }\r\n\r\n// ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    parse = (...values: any): Line => {\r\n        this._exists = false;\r\n\r\n        if (values.length === 3) {\r\n            return this.parseByCoefficient(values[0], values[1], values[2]);\r\n        } else if (values.length === 2) {\r\n            if (values[0].isPoint && values[1].isVector) {\r\n                return this.parseByPointAndVector(values[0], values[1]);\r\n            } else if (values[0].isPoint && values[1].isPoint) {\r\n                return this.parseByPointAndVector(values[0], new Vector(values[0], values[1]));\r\n            }\r\n        } else if (values.length === 1){\r\n            // It's a already a line - clone it !\r\n            if(values[0].isLine){\r\n                return values[0].clone();\r\n            }\r\n\r\n            // Maybe it's a string or an equation\r\n            let equ = new Equation(values[0]);\r\n            if(equ.isEquation){\r\n                // Check if it's a valid equation.\r\n                equ.reorder(true)\r\n\r\n                // It must contain either x, y or both.\r\n                let letters = new Set(equ.letters());\r\n\r\n                // No 'x', no 'y' in the equations\r\n                if(!(letters.has('x') || letters.has('y'))){return;}\r\n\r\n                // Another letter in the equation.\r\n                for(let elem of ['x', 'y']){\r\n                    if(letters.has(elem)){\r\n                        letters.delete(elem)}\r\n                }\r\n\r\n                if(letters.size>0){\r\n                    console.log('Extra variable in the equation.')\r\n                    return this;\r\n                }\r\n\r\n                // Everything should be ok now...\r\n                return this.parseByCoefficient(equ.left.monomByLetter('x').coefficient, equ.left.monomByLetter('y').coefficient, equ.left.monomByDegree(0).coefficient)\r\n            }\r\n        }\r\n        // TODO: Add the ability to create line from a normal vector\r\n        console.log('Someting wrong happend while creating the line')\r\n        return this;\r\n    }\r\n\r\n    parseByCoefficient = (a: Fraction, b: Fraction, c: Fraction): Line => {\r\n        this._a = new Fraction(a);\r\n        this._b = new Fraction(b);\r\n        this._c = new Fraction(c);\r\n\r\n        // TODO: initialize direction and reference point\r\n        this._d = new Vector(this._b.clone(), this._a.clone().opposed());\r\n        this._OA = new Point(new Fraction().zero(), this._c.clone());\r\n        this._n = this._d.clone().normal();\r\n\r\n        this._exists = true;\r\n        return this;\r\n    }\r\n\r\n    parseByPointAndVector = (P: Point, d: Vector): Line => {\r\n        // OX = OP + k*d\r\n        // x = px + kdx     * dy\r\n        // y = py + kdy     * dx\r\n        // ------------------\r\n        // dy * x = px * dy + kdxdy\r\n        // dx * y = py * dx + kdxdy\r\n        // ------------------\r\n        // dy * x - dx * y = px * dy - py * dx\r\n        // dy * x - dx * y - (px * dy - py * dx) = 0\r\n        this.parseByCoefficient(\r\n            d.y,\r\n            d.x.clone().opposed(),\r\n            P.x.clone().multiply(d.y).subtract(P.y.clone().multiply(d.x)).opposed()\r\n        )\r\n\r\n        // Choose the current values as point and direction vector instead of the automatic version.\r\n        this._OA = P.clone();\r\n        this._d = d.clone();\r\n        this._n = this._d.clone().normal();\r\n\r\n        this._exists = true;\r\n        return this;\r\n    }\r\n\r\n    clone = (): Line => {\r\n        this._a = this._a.clone();\r\n        this._b = this._b.clone();\r\n        this._c = this._c.clone();\r\n\r\n        this._d = this._d.clone();\r\n        this._OA = this._OA.clone();\r\n        this._n = this._n.clone();\r\n\r\n        return this;\r\n    }\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    isParellelTo = (line: Line): Boolean => {\r\n        // Do they have the isSame direction ?\r\n        return this.slope.isEqual(line.slope) && this.height.isDifferent(line.height);\r\n    }\r\n    isSameAs = (line: Line): Boolean => {\r\n        return this.slope.isEqual(line.slope) && this.height.isEqual(line.height);\r\n    }\r\n    simplifyDirection = (): Line => {\r\n        let lcm = Numeric.lcm(this._d.x.denominator, this._d.y.denominator),\r\n            gcd = Numeric.gcd(this._d.x.numerator, this._d.y.numerator);\r\n\r\n        this._d.x.multiply(lcm).divide(gcd);\r\n        this._d.y.multiply(lcm).divide(gcd);\r\n        return this;\r\n    }\r\n    intersection = (line: Line): { point: Point, hasIntersection: boolean, isParallel: boolean, isSame: boolean } => {\r\n        let Pt = new Point(), isParallel = false, isSame = false, hasIntersection = true;\r\n\r\n        // this         => ax+by+c = 0\r\n        // line         => dx+ey+f = 0\r\n        //\r\n        //  aex + bey + ce = 0\r\n        //  dbx + bey + bf = 0\r\n        // (ae-db)x + ce-bf = 0\r\n        //\r\n        //  adx + bdy + cd = 0\r\n        //  adx + aey + af = 0\r\n        // (bd-ae)y + (cd-af)\r\n        //\r\n        // x = (bf-ce)/(ae-db)\r\n        // y = (af-cd)/(bd-ae)\r\n\r\n\r\n        // Theres is no 'y'\r\n        if (this._b.isZero() || line.b.isZero()) {\r\n            // TODO : handle no y in the line canonical form\r\n        }\r\n\r\n        if (this.isParellelTo(line)) {\r\n            Pt.x = null;\r\n            Pt.y = null;\r\n            isParallel = true;\r\n        } else if (this.isSameAs(line)) {\r\n            Pt.x = null;\r\n            Pt.y = null;\r\n            isSame = true;\r\n        } else {\r\n            Pt.x = this._b.clone().multiply(line.c).subtract(this._c.clone().multiply(line.b))\r\n                .divide(this._a.clone().multiply(line.b).subtract(this._b.clone().multiply(line.a)));\r\n            Pt.y = this._a.clone().multiply(line.c).subtract(this._c.clone().multiply(line.a))\r\n                .divide(this._b.clone().multiply(line.a).subtract(this._a.clone().multiply(line.b)));\r\n        }\r\n\r\n        return {\r\n            point: Pt,\r\n            hasIntersection: !(isParallel || isSame),\r\n            isParallel,\r\n            isSame\r\n        };\r\n    }\r\n\r\n    distanceTo(pt: Point): { value: number, fraction: Fraction, tex: string } {\r\n        let numerator = pt.x.clone().multiply(this._a)\r\n                .add(pt.y.clone().multiply(this._b))\r\n                .add(this._c).abs(),\r\n            d2 = this.normal.normSquare;\r\n\r\n        // The denominator is null - shouldn't be possible\r\n        if (d2.isZero()) {\r\n            return {\r\n                value: NaN,\r\n                tex: 'Not a line',\r\n                fraction: new Fraction().infinite()\r\n            }\r\n        }\r\n        // The denominator is a perfect square - simplify the tex result\r\n        let value = numerator.value / Math.sqrt(d2.value),\r\n            F = numerator.clone().divide(d2.clone().sqrt());\r\n\r\n        // The denominator is a perfect square.\r\n        if (d2.isSquare()) {\r\n            return {\r\n                value,\r\n                tex: F.tex,\r\n                fraction: F\r\n            }\r\n        }\r\n        // Complete answer...\r\n        return {\r\n            value,\r\n            tex: `\\\\frac{${numerator.tex}}{\\\\sqrt{${d2.tex}}}`,\r\n            fraction: F\r\n        };\r\n    }\r\n\r\n    hitSegment(A: Point, B: Point): boolean {\r\n        let iPt = this.intersection(\r\n            new Line(A, B)\r\n        )\r\n\r\n        // There is an intersection point\r\n        if(iPt.hasIntersection) {\r\n            return iPt.point.x.value >= Math.min(A.x.value, B.x.value)\r\n                && iPt.point.x.value <= Math.max(A.x.value, B.x.value)\r\n                && iPt.point.y.value >= Math.min(A.y.value, B.y.value)\r\n                && iPt.point.y.value <= Math.max(A.y.value, B.y.value)\r\n        }\r\n        return false;\r\n    }\r\n    // ------------------------------------------\r\n    // Special functions\r\n    // ------------------------------------------\r\n    canonicalAsFloatCoefficient(decimals: number): string{\r\n        if(decimals===undefined){\r\n            decimals = 2;\r\n        }\r\n\r\n        let ca = this._a.value,\r\n            cb = this._b.value,\r\n            cc= this._c.value,\r\n            canonical = '';\r\n\r\n        if(!this._a.isZero()){\r\n            if(this._a.isOne()){\r\n                canonical = 'x'\r\n            }else if(this._a.clone().opposed().isOne()){\r\n                canonical = '-x'\r\n            }else{\r\n                canonical = this._a.value.toFixed(decimals)+'x'\r\n            }\r\n        }\r\n\r\n        if(!this._b.isZero()){\r\n            if(this._b.isPositive()){canonical+='+'}\r\n            canonical += this._b.value.toFixed(decimals) + 'y'\r\n        }\r\n\r\n        if(!this._c.isZero()){\r\n            if(this._c.isPositive()){canonical+='+'}\r\n            canonical += this._c.value.toFixed(decimals)\r\n        }\r\n\r\n\r\n        return canonical + '=0';\r\n    }\r\n}","/**\r\n * Vector module contains everything necessary to handle 2d or 3d vectors.\r\n * @module Vector\r\n */\r\nimport {Fraction} from \"../coefficients/fraction\";\r\n\r\n//TODO: Ajouter une vrification si la droite existe.\r\nexport class Point {\r\n    private _x: Fraction;   // 1st component\r\n    private _y: Fraction;   // 2nd component\r\n    private _exist: Boolean;\r\n\r\n    constructor(...values: any) {\r\n        this._x = new Fraction().zero();\r\n        this._y = new Fraction().zero();\r\n\r\n        if (values !== undefined) {\r\n            this.parse(...values);\r\n        }\r\n    };\r\n\r\n    get isPoint() {\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get x(): Fraction {\r\n        return this._x;\r\n    }\r\n\r\n    set x(value: Fraction) {\r\n        this._x = value;\r\n    }\r\n\r\n    get y(): Fraction {\r\n        return this._y;\r\n    }\r\n\r\n    set y(value: Fraction) {\r\n        this._y = value;\r\n    }\r\n\r\n    get tex(): string {\r\n        let pts = [];\r\n\r\n        pts.push(this._x.tex);\r\n        pts.push(this._y.tex);\r\n\r\n        return `\\\\left(${pts.join(';')}\\\\right)`\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n\r\n    parse = (...values: any): Point => {\r\n        // Initialize the value.\r\n        this.zero();\r\n\r\n        // Nothing is given\r\n        if (values.length === 0) {\r\n            return this;\r\n        }\r\n\r\n        // One element is given - might be already a point !\r\n        if (values.length === 1) {\r\n            if (values[0].isPoint) {\r\n                return values.clone();\r\n            }\r\n\r\n            // Value given as a dictionnary\r\n            if (values[0].x !== undefined && values[0].y !== undefined) {\r\n                this._x = new Fraction(values[0].x).reduce()\r\n                this._y = new Fraction(values[0].y).reduce()\r\n            } else {\r\n                return this.zero();\r\n            }\r\n        }\r\n        if (values.length === 2) {\r\n            this._x = new Fraction(values[0]).reduce()\r\n            this._y = new Fraction(values[1]).reduce()\r\n        }\r\n\r\n\r\n        return this;\r\n    };\r\n\r\n    clone = (): Point => {\r\n        let V = new Point();\r\n\r\n        if (this._x !== null) {\r\n            V.x = this._x.clone();\r\n        }\r\n        if (this._y !== null) {\r\n            V.y = this._y.clone();\r\n        }\r\n        return V;\r\n    }\r\n\r\n    zero = (): Point => {\r\n        this._x = new Fraction(null);\r\n        this._y = new Fraction(null);\r\n        return this;\r\n    }\r\n\r\n    origin = (): Point => {\r\n        this.zero();\r\n        return this;\r\n    }\r\n\r\n    middleOf = (P1: Point, P2: Point): Point => {\r\n        this._x = P1.x.clone().add(P2.x).divide(2);\r\n        this._y = P1.y.clone().add(P2.y).divide(2);\r\n\r\n        return this;\r\n    }\r\n    // ------------------------------------------\r\n    // Display functions\r\n    // ------------------------------------------\r\n    texValues = (numberOfDigits: number): string => {\r\n        let pts = [];\r\n\r\n        pts.push(this._x.value.toFixed(numberOfDigits===undefined?2:numberOfDigits));\r\n        pts.push(this._y.value.toFixed(numberOfDigits===undefined?2:numberOfDigits));\r\n\r\n        return `\\\\left(${pts.join(';')}\\\\right)`\r\n    }\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n\r\n    // ------------------------------------------\r\n    // Vector functions\r\n    // ------------------------------------------\r\n\r\n    // ------------------------------------------\r\n    // Static functions\r\n    // ------------------------------------------\r\n    static pmatrix = (a: any, b: any, c?: any): string => {\r\n        if (c === undefined) {\r\n            return `\\\\begin{pmatrix} ${a.tex ? a.tex : a} \\\\\\\\ ${b.tex ? b.tex : b} \\\\end{pmatrix}`;\r\n        } else {\r\n            return `\\\\begin{pmatrix} ${a.tex ? a.tex : a} \\\\\\\\ ${b.tex ? b.tex : b} \\\\\\\\ ${c.tex ? c.tex : c} \\\\end{pmatrix}`;\r\n        }\r\n    };\r\n\r\n}\r\n","import {Point} from \"./point\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Vector} from \"./vector\";\r\nimport {Line} from \"./line\";\r\nimport {Equation} from \"../algebra/equation\";\r\n\r\ninterface remarquableLines {\r\n    'medians': {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Point\r\n    },\r\n    'mediators': {\r\n        'AB': Line,\r\n        'AC': Line,\r\n        'BC': Line,\r\n        'intersection': Point\r\n    },\r\n    'heights': {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Point\r\n    },\r\n    'bisectors': {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Point\r\n    }\r\n}\r\n\r\nexport class Triangle {\r\n    private _A: Point;\r\n    private _B: Point;\r\n    private _C: Point;\r\n    private _lines: {\r\n        'AB': Line,\r\n        'AC': Line,\r\n        'BC': Line\r\n    };\r\n    private _middles: {\r\n        'AB': Point,\r\n        'AC': Point,\r\n        'BC': Point\r\n    };\r\n    private _remarquables: remarquableLines;\r\n\r\n\r\n    constructor(...values: any) {\r\n\r\n        if (values.length > 0) {\r\n            this.parse(...values);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    get isTriangle():boolean {return true;}\r\n\r\n    // ------------------------------------------\r\n    // Getter and setters\r\n    // ------------------------------------------\r\n\r\n    get A(): Point {\r\n        return this._A;\r\n    }\r\n\r\n    get B(): Point {\r\n        return this._B;\r\n    }\r\n\r\n    get C(): Point {\r\n        return this._C;\r\n    }\r\n\r\n    get AB(): Vector {\r\n        return this.getSegment('A', 'B');\r\n    }\r\n\r\n    get BA(): Vector {\r\n        return this.getSegment('B', 'A');\r\n    }\r\n\r\n    get BC(): Vector {\r\n        return this.getSegment('B', 'C');\r\n    }\r\n\r\n    get CB(): Vector {\r\n        return this.getSegment('C', 'B');\r\n    }\r\n\r\n    get AC(): Vector {\r\n        return this.getSegment('A', 'C');\r\n    }\r\n\r\n    get CA(): Vector {\r\n        return this.getSegment('C', 'A');\r\n    }\r\n\r\n    get isRectangle(): boolean {\r\n        if (this.AB.isNormalTo(this.BC)) {\r\n            return true;\r\n        }\r\n        if (this.AB.isNormalTo(this.AC)) {\r\n            return true;\r\n        }\r\n        if (this.BC.isNormalTo(this.AC)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    get isEquilateral(): boolean {\r\n        return this.AB.normSquare.isEqual(this.BC.normSquare) &&\r\n            this.AB.normSquare.isEqual(this.AC.normSquare);\r\n    }\r\n\r\n    get isIsocele(): boolean {\r\n        return this.AB.normSquare.isEqual(this.BC.normSquare) ||\r\n            this.AB.normSquare.isEqual(this.AC.normSquare) ||\r\n            this.BC.normSquare.isEqual(this.AC.normSquare)\r\n    }\r\n\r\n    get lines(): { 'AB': Line, 'BC': Line, 'AC': Line } {\r\n        return this._lines;\r\n    }\r\n\r\n    get remarquables(): remarquableLines {\r\n        return this._remarquables;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n\r\n    /**\r\n     * Parse values to a triangle. Supported formats:\r\n     * Point, Point, Point\r\n     * x1, y1, x2, y2, x3, y3\r\n     * TODO: Something else ?\r\n     * @param values\r\n     */\r\n    parse = (...values: any): Triangle => {\r\n        if (values.length === 6) {\r\n            // Check if all values are number or fractions.\r\n            let v = values.map((x: any) => new Fraction(x));\r\n            return this.parse(\r\n                new Point(v[0], v[1]),\r\n                new Point(v[2], v[3]),\r\n                new Point(v[4], v[5]),\r\n            )\r\n        } else if (values.length === 3) {\r\n            // Possibilities:\r\n            // - Three points (or part of points, only dict for example, or array (TODO: Add the array syntax for point)\r\n            // - Three lines\r\n            // - Three lines as text.\r\n            if(values.filter((x:any) => typeof x === 'string').length===3) {\r\n                return this.parse( ...values.map((x:string) => new Line(x)) )\r\n            }else if(values.filter((x:any) => x.isLine === true).length===3) {\r\n                // We have three lines\r\n                this._lines = {\r\n                    'AB': values[0],\r\n                    'BC': values[1],\r\n                    'AC': values[2]\r\n                };\r\n\r\n                // Get the intersection points -> build the triangle using these intersection points.\r\n                let intersect = values[0].intersection(values[1]);\r\n                if (intersect.hasIntersection) {\r\n                    this._B = intersect.point.clone();\r\n                } else {\r\n                    return this;\r\n                }\r\n                intersect = values[1].intersection(values[2]);\r\n                if (intersect.hasIntersection) {\r\n                    this._C = intersect.point.clone();\r\n                } else {\r\n                    return this;\r\n                }\r\n                intersect = values[2].intersection(values[0]);\r\n                if (intersect.hasIntersection) {\r\n                    this._A = intersect.point.clone();\r\n                } else {\r\n                    return this;\r\n                }\r\n            }else {\r\n                // At least, one of the value is not a point.\r\n                if (values.filter((x: any) => x.isPoint === true).length < 3) {\r\n                    return this.parse(\r\n                        new Point(values[0]),\r\n                        new Point(values[1]),\r\n                        new Point(values[2])\r\n                    )\r\n                }\r\n\r\n                // We have three points.\r\n                this._A = values[0].clone();\r\n                this._B = values[1].clone();\r\n                this._C = values[2].clone();\r\n\r\n                this._lines = {\r\n                    'AB': new Line(this._A, this._B),\r\n                    'BC': new Line(this._B, this._C),\r\n                    'AC': new Line(this._A, this._C)\r\n                };\r\n            }\r\n        } else if (values.length === 1) {\r\n            if (values[0].isTriangle === true) {\r\n                return values[0].clone();\r\n            }\r\n        }\r\n\r\n        this._updateTriangle();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clone the Triangle class\r\n     */\r\n    clone = (): Triangle => {\r\n        this._A = this._A.clone();\r\n        this._B = this._B.clone();\r\n        this._C = this._C.clone();\r\n\r\n        this._lines = {\r\n            'AB': this._lines.AB.clone(),\r\n            'BC': this._lines.BC.clone(),\r\n            'AC': this._lines.AC.clone()\r\n        }\r\n\r\n        this._updateTriangle();\r\n        return this;\r\n    }\r\n\r\n\r\n    // ------------------------------------------\r\n    // Triangle operations and properties\r\n    // ------------------------------------------\r\n\r\n    /**\r\n     * Generate the Line object for the three segments of the triangle\r\n     */\r\n    private _updateTriangle = () => {\r\n        this._middles = {\r\n            'AB': new Point().middleOf(this._A, this._B),\r\n            'AC': new Point().middleOf(this._A, this._C),\r\n            'BC': new Point().middleOf(this._B, this._C)\r\n        }\r\n\r\n        this._remarquables = this._calculateRemarquableLines();\r\n    }\r\n\r\n\r\n    /**\r\n     * Get the Point class for the given name\r\n     * @param ptName\r\n     */\r\n    private getPointByName = (ptName: string): Point => {\r\n        switch (ptName.toUpperCase()) {\r\n            case 'A':\r\n                return this._A;\r\n            case 'B':\r\n                return this._B;\r\n            case 'C':\r\n                return this._C;\r\n        }\r\n\r\n        // Something went wrong ! Return the first point\r\n        return this._A;\r\n    }\r\n    /**\r\n     * Get the vector for the segment given by name.\r\n     * @param ptName1\r\n     * @param ptName2\r\n     */\r\n    private getSegment = (ptName1: string, ptName2: string): Vector => {\r\n        return new Vector(\r\n            this.getPointByName(ptName1),\r\n            this.getPointByName(ptName2)\r\n        );\r\n    }\r\n\r\n    private _calculateRemarquableLines = (): remarquableLines => {\r\n        let remarquables: remarquableLines = {\r\n            'medians': {\r\n                'A': new Line(this._A, this._middles.BC),\r\n                'B': new Line(this._B, this._middles.AC),\r\n                'C': new Line(this._C, this._middles.AB),\r\n                'intersection': null\r\n            },\r\n            'mediators': {\r\n                'AB': new Line(this._middles.AB, new Vector(this._A, this._B).normal()),\r\n                'AC': new Line(this._middles.AC, new Vector(this._A, this._C).normal()),\r\n                'BC': new Line(this._middles.BC, new Vector(this._B, this._C).normal()),\r\n                'intersection': null\r\n            },\r\n            'heights': {\r\n                'A': new Line(this._A, new Vector(this._B, this._C).normal()),\r\n                'B': new Line(this._B, new Vector(this._A, this._C).normal()),\r\n                'C': new Line(this._C, new Vector(this._A, this._B).normal()),\r\n                'intersection': null\r\n            },\r\n            'bisectors': {\r\n                'A': this._calculateBisectors('A'),\r\n                'B': this._calculateBisectors('B'),\r\n                'C': this._calculateBisectors('C'),\r\n                'intersection': null\r\n            }\r\n        }\r\n\r\n        // As it's a triangle, we assume the lines are intersecting and aren't parallel or superposed.\r\n        remarquables.medians.intersection = remarquables.medians.A.intersection(remarquables.medians.B).point;\r\n        remarquables.mediators.intersection = remarquables.mediators.AB.intersection(remarquables.mediators.BC).point;\r\n        remarquables.heights.intersection = remarquables.heights.A.intersection(remarquables.heights.B).point;\r\n        remarquables.bisectors.intersection = remarquables.bisectors.A.intersection(remarquables.bisectors.B).point;\r\n\r\n        // Everything was calculated for the remarquable lines.\r\n        return remarquables;\r\n    }\r\n\r\n    private _calculateBisectors = (pt: string): Line => {\r\n        let tlines = this.lines, d1, d2;\r\n\r\n        if(pt==='A'){\r\n            d1 = tlines.AB;\r\n            d2 = tlines.AC;\r\n        }else if(pt==='B'){\r\n            d1 = tlines.AB;\r\n            d2 = tlines.BC;\r\n        }else if(pt==='C'){\r\n            d1 = tlines.BC;\r\n            d2 = tlines.AC;\r\n        }\r\n\r\n        let b1 = new Line(new Equation(d1.equation.left.clone().multiply(d2.n.simplify().norm), d2.equation.left.clone().multiply(d1.n.simplify().norm)).reorder(true).simplify()),\r\n            b2 = new Line(new Equation(d1.equation.left.clone().multiply(d2.n.simplify().norm), d2.equation.left.clone().multiply(d1.n.simplify().norm).opposed()).reorder(true).simplify());\r\n\r\n        // Must determine which bisectors is in the triangle\r\n        if(pt==='A'){\r\n            return b1.hitSegment(this.B, this.C)?b1:b2;\r\n        }\r\n        if(pt==='B'){\r\n            return b1.hitSegment(this.A, this.C)?b1:b2;\r\n        }\r\n        if(pt==='C'){\r\n            return b1.hitSegment(this.B, this.A)?b1:b2;\r\n        }\r\n\r\n        // Default returns the first bisector\r\n        return b1;\r\n    }\r\n}","/**\r\n * Vector module contains everything necessary to handle 2d or 3d vectors.\r\n * @module Vector\r\n */\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Numeric} from \"../numeric\";\r\n\r\nexport class Vector {\r\n    private _x: Fraction;   // 1st component\r\n    private _y: Fraction;   // 2nd component\r\n\r\n    constructor(...values: any) {\r\n        this._x = new Fraction().zero();\r\n        this._y = new Fraction().zero();\r\n\r\n        if (values !== undefined) {\r\n            this.parse(...values);\r\n        }\r\n    };\r\n\r\n    get isVector() {\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get x(): Fraction {\r\n        return this._x;\r\n    }\r\n\r\n    set x(value: Fraction) {\r\n        this._x = value;\r\n    }\r\n\r\n    get y(): Fraction {\r\n        return this._y;\r\n    }\r\n\r\n    set y(value: Fraction) {\r\n        this._y = value;\r\n    }\r\n\r\n    get normSquare(): Fraction {\r\n        return this._x.clone().pow(2).add(this._y.clone().pow(2));\r\n    }\r\n\r\n    get norm(): number {\r\n        return Math.sqrt(this.normSquare.value);\r\n    }\r\n\r\n    get tex(): string {\r\n        return `\\\\begin{pmatrix}${this._x.tex} \\\\\\\\\\ ${this._y.tex} \\\\end{pmatrix}`\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n\r\n    parse = (...values: any): Vector => {\r\n        // TODO: Must be more strict about what is given and limit to two dimensional vectors.p\r\n        // Maybe more than one value was given...\r\n        // Initialize the vector\r\n        this.zero();\r\n\r\n        if (values.length === 0) {\r\n            return this;\r\n        }\r\n\r\n        if (values.length === 1) {\r\n            if (values[0].isVector) {\r\n                return values[0].clone()\r\n            } else {\r\n                return this._parseString(values[0])\r\n            }\r\n        }\r\n\r\n        if (values.length >= 2) {\r\n            // Two points are given - skip the third value.\r\n            if (values[0].isPoint && values[1].isPoint) {\r\n                this._x = values[1].x.clone().subtract(values[0].x)\r\n                this._y = values[1].y.clone().subtract(values[0].y)\r\n                return this;\r\n            }\r\n\r\n            // Fractions or a number are give\r\n            if (values[0].isFraction || !isNaN(values[0])) {\r\n                this._x = new Fraction(values[0])\r\n            }\r\n            if (values[1].isFraction || !isNaN(values[1])) {\r\n                this._y = new Fraction(values[1])\r\n            }\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    clone = (): Vector => {\r\n        let V = new Vector();\r\n\r\n        if (this._x !== null) {\r\n            V.x = this._x.clone();\r\n        }\r\n        if (this._y !== null) {\r\n            V.y = this._y.clone();\r\n        }\r\n        return V;\r\n    }\r\n\r\n    reset = (): Vector => {\r\n        this._x = null;\r\n        this._y = null;\r\n        return this;\r\n    }\r\n\r\n    zero = (): Vector => {\r\n        this.reset();\r\n        this._x = new Fraction(null);\r\n        this._y = new Fraction(null);\r\n        return this;\r\n    }\r\n\r\n    one = (): Vector => {\r\n        this._x = new Fraction();\r\n        this._y = new Fraction();\r\n        return this;\r\n    }\r\n\r\n    private _parseString = (value: string): Vector => {\r\n        // Split comma, semi colon or single space.\r\n        let components = value.split(/[,;\\s]/g);\r\n\r\n        // Validate the fraction values.\r\n        this.x = new Fraction(components[0] || null);\r\n        this.y = new Fraction(components[1] || null);\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    opposed = (): Vector => {\r\n        this._x.opposed();\r\n        this._y.opposed();\r\n        return this;\r\n    }\r\n\r\n    add = (V: Vector): Vector => {\r\n        this._x.add(V.x);\r\n        this._y.add(V.y);\r\n\r\n        return this;\r\n    }\r\n\r\n    subtract = (V: Vector): Vector => {\r\n        return this.add(V.clone().opposed());\r\n    }\r\n\r\n    scalarProductWithVector = (V: Vector): Fraction => {\r\n        // TODO: Add the scalar factor !!!!\r\n        return this._x.clone().multiply(V.x).add(this._y.clone().multiply(V.y));\r\n    }\r\n\r\n    static scalarProduct = (v1: Vector, v2: Vector): number => {\r\n        // TODO: Transform to fraction with nthroot.\r\n        return  v1.x.value * v2.x.value + v1.y.value * v2.y.value;\r\n    };\r\n\r\n    normal = (): Vector => {\r\n        let x = this.x.clone().opposed(), y = this.y.clone();\r\n        this._x = y;\r\n        this._y = x;\r\n        return this;\r\n    }\r\n\r\n    isNormalTo = (v: Vector): boolean => {\r\n        return this.scalarProductWithVector(v).isZero()\r\n    }\r\n\r\n    multiplyByScalar = (k: any): Vector => {\r\n        let scalar = new Fraction(k);\r\n        this._x.multiply(scalar);\r\n        this._y.multiply(scalar);\r\n        return this;\r\n    }\r\n\r\n    divideByScalar = (k:any): Vector => {\r\n        return this.multiplyByScalar(new Fraction(k).invert());\r\n    }\r\n    // ------------------------------------------\r\n    // Vector functions\r\n    // ------------------------------------------\r\n\r\n    simplify = (): Vector => {\r\n        // Multiply by the lcm of denominators.\r\n        return this.multiplyByScalar(Numeric.lcm(this._x.denominator, this._y.denominator))\r\n            .divideByScalar(Numeric.gcd(this._x.numerator, this._y.numerator));\r\n    }\r\n\r\n    angleWith = (V: Vector, sharp?: Boolean, radian?: Boolean): number => {\r\n        let scalar = this.scalarProductWithVector(V).value,\r\n            toDegree = radian ? 1 : 180 / Math.PI;\r\n        if (sharp) {\r\n            scalar = Math.abs(scalar);\r\n        }\r\n\r\n        return toDegree * Math.acos(scalar / (this.norm * V.norm));\r\n    }\r\n}\r\n","export class Numeric{\r\n    static round(value:number, decimals:number=2):number {\r\n        return Number(Math.round(Number(value+'e'+decimals))+'e-'+decimals);\r\n    }\r\n\r\n    /**\r\n     * Get the list of the nth first prime numbers.\r\n     * @param nb : number of primes to choose from\r\n     */\r\n    static prime(nb?:number):number[]{\r\n        let primes:number[] = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973];\r\n        if(nb === undefined){\r\n            return primes;\r\n        }else{\r\n            return primes.slice(0,Math.max(primes.length,nb));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the list of all dividers of a number.\r\n     * @param value\r\n     */\r\n    static dividers(value:number):number[]{\r\n        let D: number[];\r\n        const maxV = Math.sqrt(Math.abs(value));\r\n\r\n        // Initialize the list of dividers.\r\n        D = [];\r\n\r\n        for(let i=1; i<=maxV; i++){\r\n            if(value%i===0){\r\n                D.push(i);\r\n                D.push(value/i);\r\n            }\r\n        }\r\n\r\n        // Order numbers.\r\n        D.sort(function(a, b){return a-b;});\r\n\r\n        // Make sure the array of value is unique.\r\n        return [...new Set(D)];\r\n    }\r\n    /**\r\n     * Great Common Divisor\r\n     * @param values : number values\r\n     */\r\n    static gcd(...values:number[]):number{\r\n        // Define the gcd for two number\r\n        let gcd2 = function(a:number,b:number):number{\r\n            if(b===0){return a;}\r\n            return gcd2(b, a%b);\r\n        };\r\n\r\n        let g:number = 1,\r\n            i:number = 2;\r\n\r\n        // Nothing is given\r\n        if(values.length===0){return 1;}\r\n        // Only one number is given\r\n        if(values.length===1){\r\n            // The first number is zero\r\n            if(values[0]===0){return 1;}\r\n            // Return the number\r\n            return values[0];\r\n        }\r\n\r\n        // We have at least 2 numbers.\r\n        g = gcd2(values[0],values[1]);\r\n\r\n        // The gcd of the two first value is one ? It's already finished.\r\n        if(g===1){return 1;}\r\n\r\n        // The current gcd isn't one. Continue with all next values.\r\n        for(i=2; i<values.length; i++){\r\n            g = gcd2(g, values[i]);\r\n            // Escape if gcd is already one.\r\n            if(g===1){break;}\r\n        }\r\n\r\n        return Math.abs(g);\r\n    }\r\n\r\n    /**\r\n     * Least Common Multiple\r\n     * @param values: list of numbers\r\n     */\r\n    static lcm(...values:number[]):number{\r\n        return values.reduce(function(a,b){\r\n            return Math.abs(a * b / Numeric.gcd(a, b));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Random boolean with a percent ratio\r\n     * @param percent\r\n     */\r\n    static randomBool(percent:number=0.5):boolean{\r\n        return Math.random()<percent;\r\n    }\r\n\r\n    /**\r\n     * Random integer between two values.\r\n     * @param a (number) : From this value to the second value. If the second is ommited, this value is the max value.\r\n     * @param b (number) : To this value. If this is ommited.\r\n     */\r\n    static randomInt(a:number, b?:number):number{\r\n        if(b===undefined){return Numeric.randomInt(0,a);}\r\n\r\n        return Math.floor(Math.random() * (b - a + 1) + a);\r\n    }\r\n\r\n    /**\r\n     * Random integer between -max and max value.\r\n     * @param max (number) : determine the limits.\r\n     * @param zero (bool) : determine if zero is allowed or not.\r\n     */\r\n    static randomIntSym(max:number, zero?:boolean):number{\r\n        if(zero===false){\r\n            return Numeric.randomBool()?this.randomInt(1,max):-this.randomInt(1,max);\r\n        }else{\r\n            return Numeric.randomInt(-max, max);\r\n        }\r\n    }\r\n}","export class Shutingyard {\r\n    private _rpn: string[] = [];\r\n\r\n    /**\r\n     * Determin if the token is a defined operation\r\n     * Defined operations: + - * / ^ sin cos tan\r\n     * @param token\r\n     */\r\n    isOperation(token: string): boolean {\r\n        if (token[0].match(/[+\\-*/^]/g)) {\r\n            return true;\r\n        }\r\n        if (token.match(/^sin|cos|tan/g)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the next token to analyse.\r\n     * @param expr (string) Expression to analyse\r\n     * @param start (number) CUrrent position in the expr string.\r\n     */\r\n    NextToken(expr: string, start: number): [string, number, string] {\r\n        let tokenMatch: string[], token: string, tokenType: string;\r\n\r\n        // Detect a fraction monoms or return empty array\r\n        tokenMatch = (expr.substr(start).match(/^[0-9/a-z^]+/g)) || [];\r\n\r\n        if (tokenMatch.length > 0) {\r\n            token = tokenMatch[0];\r\n            tokenType = 'monom';\r\n        }\r\n        // It's an operation !\r\n        else if (expr[start].match(/[+\\-*/^]/g)) {\r\n            token = expr[start];\r\n            tokenType = 'operation';\r\n        }\r\n        // It's an opening parenthese\r\n        else if (expr[start] === '(') {\r\n            token = '(';\r\n            tokenType = '(';\r\n        }\r\n        // It's a closing parenthese\r\n        else if (expr[start] === ')') {\r\n            token = ')';\r\n            tokenType = ')';\r\n        }\r\n        // It's an argument separator for a function\r\n        else if (expr[start] === ',') {\r\n            token = ',';\r\n            tokenType = 'function-argument';\r\n        }\r\n        // It's a (basic) trigonometry function\r\n        else if (expr.match(/^(sin|cos|tan)/g)) {\r\n            token = ')';\r\n            tokenType = ')';\r\n        }\r\n            // TODO: Add other functions !\r\n\r\n        // It's a monom.\r\n        else {\r\n            // TODO: Actually, negative exposant aren't supported.\r\n            // token = (expr.substr(start).match(/^[\\da-z\\^]+/g)[0])||'';\r\n            token = tokenMatch[0];\r\n            tokenType = 'monom';\r\n\r\n            if (token === '') {\r\n                token = expr[start];\r\n                tokenType = 'monom';\r\n                console.log('SHUTING YARD - NEXT TOKEN: error at ', start);\r\n            }\r\n        }\r\n\r\n\r\n        // console.log(token, start + token.length, tokenType);\r\n        return [token, start + token.length, tokenType];\r\n    }\r\n\r\n    /**\r\n     * Sanitize an expression by adding missing common operation (multiplication between parentheseses)\r\n     * @param expr\r\n     * @constructor\r\n     */\r\n    Uniformizer(expr: string): string {\r\n        let expr2;\r\n        // Replace missing multiplication between two parenthese\r\n        expr2 = expr.replace(/\\)\\(/g, ')*(');\r\n\r\n        // Replace missing multiplication between number or setLetter and parenthese.\r\n        expr2 = expr2.replace(/([\\da-z])(\\()/g, \"$1*$2\");\r\n        expr2 = expr2.replace(/(\\))([\\da-z])/g, \"$1*$2\");\r\n\r\n        // TODO: must handle trigonometric or any other function identifier\r\n        return expr2;\r\n    }\r\n\r\n    /**\r\n     * Parse an expression using the shutting yard tree algorithms\r\n     * @param expr (string) Expression to analyse\r\n     * Returns a RPN list of items.\r\n     */\r\n    parse(expr: string): Shutingyard {\r\n        let outQueue: string[] = [],\r\n            opStack: string[] = [],\r\n            precedence: { [Key: string]: number } = {\r\n                '^': 4,\r\n                '*': 3,\r\n                '/': 3,\r\n                '+': 2,\r\n                '-': 2\r\n            },\r\n            associative: { [Key: string]: string } = {\r\n                '^': 'right',\r\n                '*': 'left',\r\n                '/': 'left',\r\n                '+': 'left',\r\n                '-': 'left'\r\n            },\r\n            token: string = '',\r\n            tokenPos: number = 0,\r\n            tokenType: string = '';\r\n\r\n        expr = this.Uniformizer(expr);\r\n\r\n        let securityLoopLvl1 = 50,\r\n            securityLoopLvl2_default = 50,\r\n            securityLoopLvl2;\r\n\r\n        while (tokenPos < expr.length) {\r\n            securityLoopLvl1--;\r\n            if (securityLoopLvl1 === 0) {\r\n                console.log('SECURITY LEVEL 1 EXIT');\r\n                break;\r\n            }\r\n\r\n            // Get the next token and the corresponding new (ending) position\r\n            [token, tokenPos, tokenType] = this.NextToken(expr, tokenPos);\r\n\r\n            switch (tokenType) {\r\n                case 'monom':\r\n                    outQueue.push(token);\r\n                    break;\r\n                case 'operation':\r\n                    //If the token is an operator, o1, then:\r\n\r\n                    if (opStack.length > 0) {\r\n                        let opTop = opStack[opStack.length - 1];\r\n\r\n                        securityLoopLvl2 = +securityLoopLvl2_default;\r\n\r\n                        //while there is an operator token o2, at the top of the operator stack and\r\n                        while (opTop in associative && (\r\n                                //either o1 is left-associative and its precedence is less than or equal to that of o2,\r\n                                (associative[token] === 'left' && precedence[token] <= precedence[opTop])\r\n                                ||\r\n                                //or o1 is right associative, and has precedence less than that of o2,\r\n                                (associative[token] === 'right' && precedence[token] < precedence[opTop])\r\n                            )\r\n                            ) {\r\n\r\n                            /* Security exit ! */\r\n                            securityLoopLvl2--;\r\n                            if (securityLoopLvl2 === 0) {\r\n                                console.log('SECURITY LEVEL 2 OPERATION EXIT');\r\n                                break;\r\n                            }\r\n\r\n                            // Add the operation to the queue\r\n                            outQueue.push((opStack.pop()) || '');\r\n\r\n                            // Get the next operation on top of the Stack.\r\n                            opTop = opStack[opStack.length - 1];\r\n                        }\r\n                    }\r\n                    //at the end of iteration push o1 onto the operator stack\r\n                    opStack.push(token);\r\n                    break;\r\n                case 'trigo':\r\n                    opStack.push(token);\r\n                    break;\r\n                case 'function-argument':\r\n                    // TODO: check if the opStack exist.\r\n                    securityLoopLvl2 = +securityLoopLvl2_default;\r\n                    while (opStack[opStack.length - 1] !== '(' && opStack.length > 0) {\r\n                        securityLoopLvl2--;\r\n                        if (securityLoopLvl2 === 0) {\r\n                            console.log('SECURITY LEVEL 2 FUNCTION ARGUMENT EXIT');\r\n                            break;\r\n                        }\r\n\r\n                        outQueue.push((opStack.pop()) || '');\r\n                    }\r\n                    break;\r\n                case '(':\r\n                    opStack.push(token);\r\n                    // Add an empty value if next element is negative.\r\n                    // console.log(token, tokenPos, expr[tokenPos], expr[tokenPos+1]);\r\n                    if(expr[tokenPos]==='-') {\r\n                        outQueue.push('0');\r\n                    }\r\n                    break;\r\n                case ')':\r\n                    securityLoopLvl2 = +securityLoopLvl2_default;\r\n                    //Until the token at the top of the stack is a left parenthesis, pop operators off the stack onto the output queue.\r\n                    while (opStack[opStack.length - 1] !== '(' && opStack.length > 1 /*Maybe zero !? */) {\r\n                        securityLoopLvl2--;\r\n                        if (securityLoopLvl2 === 0) {\r\n                            console.log('SECURITY LEVEL 2 CLOSING PARENTHESE EXIT');\r\n                            break;\r\n                        }\r\n\r\n                        outQueue.push((opStack.pop()) || '');\r\n                    }\r\n\r\n                    //Pop the left parenthesis from the stack, but not onto the output queue.\r\n                    opStack.pop();\r\n                    break;\r\n                default:\r\n                    // In theory, everything should be handled.\r\n                    console.log(`SHUTING YARD: ${tokenType} : ${token} `);\r\n            }\r\n\r\n            // Output\r\n            // console.log(outQueue.concat(opStack.reverse()).join(\" \"));\r\n        }\r\n\r\n        // console.log(outQueue.concat(opStack.reverse()));\r\n        this._rpn = outQueue.concat(opStack.reverse());\r\n\r\n        return this;\r\n    }\r\n\r\n\r\n    // Getter\r\n    get rpn() {\r\n        return this._rpn;\r\n    }\r\n\r\n\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import {Fraction} from \"./maths/coefficients/fraction\";\r\nimport {Numeric} from \"./maths/numeric\";\r\nimport {Nthroot} from \"./maths/coefficients/nthroot\";\r\nimport {Monom} from \"./maths/algebra/monom\";\r\nimport {Polynom} from \"./maths/algebra/polynom\";\r\nimport {Equation} from \"./maths/algebra/equation\";\r\nimport {LinearSystem} from \"./maths/algebra/linearSystem\";\r\nimport {Rational} from \"./maths/algebra/rational\";\r\nimport {Vector} from \"./maths/geometry/vector\";\r\nimport {Line} from \"./maths/geometry/line\";\r\nimport {Point} from \"./maths/geometry/point\";\r\nimport {Triangle} from \"./maths/geometry/triangle\";\r\n\r\n// Expose as global\r\n(<any>window).Pi = {\r\n    Numeric: Numeric,\r\n    Fraction: Fraction,\r\n    Root: Nthroot,\r\n    Monom: Monom,\r\n    Polynom: Polynom,\r\n    Equation: Equation,\r\n    LinearSystem: LinearSystem,\r\n    Rational: Rational,\r\n    Geometry: {\r\n        Vector: Vector,\r\n        Point: Point,\r\n        Line: Line,\r\n        Triangle: Triangle\r\n    }\r\n};\r\n\r\nexport var Pi = {\r\n    Numeric: Numeric,\r\n    Fraction: Fraction,\r\n    Root: Nthroot,\r\n    Monom: Monom,\r\n    Polynom: Polynom,\r\n    Equation: Equation,\r\n    LinearSystem: LinearSystem,\r\n    Rational: Rational,\r\n    Geometry: {\r\n        Vector: Vector,\r\n        Point: Point,\r\n        Line: Line,\r\n        Triangle: Triangle\r\n    }\r\n};\r\n"],"sourceRoot":""}